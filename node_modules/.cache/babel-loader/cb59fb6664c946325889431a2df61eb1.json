{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar patternParts = {\n  value: '[-+]?(?:Infinity|[[0-9]*\\\\.?\\\\d*(?:[eE][-+]?\\\\d+)?)',\n  leftBrace: '[\\\\(\\\\]\\\\[]',\n  delimeter: ',',\n  rightBrace: '[\\\\)\\\\]\\\\[]'\n};\nvar PATTERN = new RegExp(\"(\" + patternParts.leftBrace + \")\" + (\"(\" + patternParts.value + \")?\") + (\"(\" + patternParts.delimeter + \")?\") + (\"(\" + patternParts.value + \")?\") + (\"(\" + patternParts.rightBrace + \")\"));\n\nfunction execPattern(str) {\n  var match = PATTERN.exec(str);\n\n  if (!match) {\n    return null;\n  }\n\n  var _ = match[0],\n      leftBrace = match[1],\n      fromValue = match[2],\n      delimeter = match[3],\n      toValue = match[4],\n      rightBrace = match[5];\n  return {\n    leftBrace: leftBrace,\n    fromValue: fromValue,\n    delimeter: delimeter,\n    toValue: toValue,\n    rightBrace: rightBrace\n  };\n}\n\nfunction parse(str) {\n  var match = execPattern(str);\n\n  if (!match) {\n    return null;\n  }\n\n  return {\n    from: {\n      value: match.fromValue !== undefined ? +match.fromValue : -Infinity,\n      included: match.leftBrace === '['\n    },\n    to: {\n      value: match.toValue !== undefined ? +match.toValue : match.delimeter ? +Infinity : match.fromValue !== undefined ? +match.fromValue : NaN,\n      included: match.rightBrace === ']'\n    }\n  };\n}\n\nfunction check(interval) {\n  if (interval.from.value === interval.to.value) {\n    return interval.from.included && interval.to.included;\n  }\n\n  return Math.min(interval.from.value, interval.to.value) === interval.from.value;\n}\n\nfunction entry(str) {\n  var interval = parse(str);\n\n  if (!interval || !check(interval)) {\n    return null;\n  }\n\n  return interval;\n}\n\nexports.default = entry;","map":{"version":3,"sources":["/home/prepelicamangalica/WorkspaceGit/SuperProjekt/src/main/ui/node_modules/math-interval-parser/lib/index.js"],"names":["Object","defineProperty","exports","value","patternParts","leftBrace","delimeter","rightBrace","PATTERN","RegExp","execPattern","str","match","exec","_","fromValue","toValue","parse","from","undefined","Infinity","included","to","NaN","check","interval","Math","min","entry","default"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar patternParts = {\n    value: '[-+]?(?:Infinity|[[0-9]*\\\\.?\\\\d*(?:[eE][-+]?\\\\d+)?)',\n    leftBrace: '[\\\\(\\\\]\\\\[]',\n    delimeter: ',',\n    rightBrace: '[\\\\)\\\\]\\\\[]',\n};\nvar PATTERN = new RegExp(\"(\" + patternParts.leftBrace + \")\" +\n    (\"(\" + patternParts.value + \")?\") +\n    (\"(\" + patternParts.delimeter + \")?\") +\n    (\"(\" + patternParts.value + \")?\") +\n    (\"(\" + patternParts.rightBrace + \")\"));\nfunction execPattern(str) {\n    var match = PATTERN.exec(str);\n    if (!match) {\n        return null;\n    }\n    var _ = match[0], leftBrace = match[1], fromValue = match[2], delimeter = match[3], toValue = match[4], rightBrace = match[5];\n    return {\n        leftBrace: leftBrace,\n        fromValue: fromValue,\n        delimeter: delimeter,\n        toValue: toValue,\n        rightBrace: rightBrace,\n    };\n}\nfunction parse(str) {\n    var match = execPattern(str);\n    if (!match) {\n        return null;\n    }\n    return {\n        from: {\n            value: match.fromValue !== undefined ?\n                +match.fromValue :\n                -Infinity,\n            included: match.leftBrace === '['\n        },\n        to: {\n            value: match.toValue !== undefined ?\n                +match.toValue :\n                (match.delimeter ?\n                    +Infinity :\n                    match.fromValue !== undefined ?\n                        +match.fromValue :\n                        NaN),\n            included: match.rightBrace === ']'\n        }\n    };\n}\nfunction check(interval) {\n    if (interval.from.value === interval.to.value) {\n        return interval.from.included && interval.to.included;\n    }\n    return Math.min(interval.from.value, interval.to.value) === interval.from.value;\n}\nfunction entry(str) {\n    var interval = parse(str);\n    if (!interval || !check(interval)) {\n        return null;\n    }\n    return interval;\n}\nexports.default = entry;\n"]},"metadata":{},"sourceType":"script"}