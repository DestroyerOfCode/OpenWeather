{"ast":null,"code":"/**\n * @author      Created by Marcus Spiegel <spiegel@uscreen.de> on 2011-03-25.\n * @link        https://github.com/mashpie/i18n-node\n * @license     http://opensource.org/licenses/MIT\n */\n'use strict'; // dependencies\n\nvar vsprintf = require('sprintf-js').vsprintf;\n\nvar pkgVersion = require('./package.json').version;\n\nvar fs = require('fs');\n\nvar url = require('url');\n\nvar path = require('path');\n\nvar debug = require('debug')('i18n:debug');\n\nvar warn = require('debug')('i18n:warn');\n\nvar error = require('debug')('i18n:error');\n\nvar Mustache = require('mustache');\n\nvar Messageformat = require('messageformat');\n\nvar MakePlural = require('make-plural');\n\nvar parseInterval = require('math-interval-parser').default; // utils\n\n\nvar escapeRegExp = function (string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}; // create constructor function\n\n\nconst i18n = function I18n(_OPTS = false) {\n  var MessageformatInstanceForLocale = {};\n  var PluralsForLocale = {};\n  var locales = {};\n  var api = {\n    __: '__',\n    __n: '__n',\n    __l: '__l',\n    __h: '__h',\n    __mf: '__mf',\n    getLocale: 'getLocale',\n    setLocale: 'setLocale',\n    getCatalog: 'getCatalog',\n    getLocales: 'getLocales',\n    addLocale: 'addLocale',\n    removeLocale: 'removeLocale'\n  };\n  var mustacheConfig = {\n    tags: ['{{', '}}'],\n    disable: false\n  };\n  var mustacheRegex;\n  var pathsep = path.sep; // ---> means win support will be available in node 0.8.x and above\n\n  var autoReload;\n  var cookiename;\n  var languageHeaderName;\n  var defaultLocale;\n  var retryInDefaultLocale;\n  var directory;\n  var directoryPermissions;\n  var extension;\n  var fallbacks;\n  var indent;\n  var logDebugFn;\n  var logErrorFn;\n  var logWarnFn;\n  var preserveLegacyCase;\n  var objectNotation;\n  var prefix;\n  var queryParameter;\n  var register;\n  var updateFiles;\n  var syncFiles;\n  var missingKeyFn; // public exports\n\n  var i18n = {};\n  i18n.version = pkgVersion;\n\n  i18n.configure = function i18nConfigure(opt) {\n    // reset locales\n    locales = {}; // Provide custom API method aliases if desired\n    // This needs to be processed before the first call to applyAPItoObject()\n\n    if (opt.api && typeof opt.api === 'object') {\n      for (var method in opt.api) {\n        if (Object.prototype.hasOwnProperty.call(opt.api, method)) {\n          var alias = opt.api[method];\n\n          if (typeof api[method] !== 'undefined') {\n            api[method] = alias;\n          }\n        }\n      }\n    } // you may register i18n in global scope, up to you\n\n\n    if (typeof opt.register === 'object') {\n      register = opt.register; // or give an array objects to register to\n\n      if (Array.isArray(opt.register)) {\n        register = opt.register;\n        register.forEach(function (r) {\n          applyAPItoObject(r);\n        });\n      } else {\n        applyAPItoObject(opt.register);\n      }\n    } // sets a custom cookie name to parse locale settings from\n\n\n    cookiename = typeof opt.cookie === 'string' ? opt.cookie : null; // set the custom header name to extract the language locale\n\n    languageHeaderName = typeof opt.header === 'string' ? opt.header : 'accept-language'; // query-string parameter to be watched - @todo: add test & doc\n\n    queryParameter = typeof opt.queryParameter === 'string' ? opt.queryParameter : null; // where to store json files\n\n    directory = typeof opt.directory === 'string' ? opt.directory : path.join(__dirname, 'locales'); // permissions when creating new directories\n\n    directoryPermissions = typeof opt.directoryPermissions === 'string' ? parseInt(opt.directoryPermissions, 8) : null; // write new locale information to disk\n\n    updateFiles = typeof opt.updateFiles === 'boolean' ? opt.updateFiles : true; // sync locale information accros all files\n\n    syncFiles = typeof opt.syncFiles === 'boolean' ? opt.syncFiles : false; // what to use as the indentation unit (ex: \"\\t\", \"  \")\n\n    indent = typeof opt.indent === 'string' ? opt.indent : '\\t'; // json files prefix\n\n    prefix = typeof opt.prefix === 'string' ? opt.prefix : ''; // where to store json files\n\n    extension = typeof opt.extension === 'string' ? opt.extension : '.json'; // setting defaultLocale\n\n    defaultLocale = typeof opt.defaultLocale === 'string' ? opt.defaultLocale : 'en'; // allow to retry in default locale, useful for production\n\n    retryInDefaultLocale = typeof opt.retryInDefaultLocale === 'boolean' ? opt.retryInDefaultLocale : false; // auto reload locale files when changed\n\n    autoReload = typeof opt.autoReload === 'boolean' ? opt.autoReload : false; // enable object notation?\n\n    objectNotation = typeof opt.objectNotation !== 'undefined' ? opt.objectNotation : false;\n    if (objectNotation === true) objectNotation = '.'; // read language fallback map\n\n    fallbacks = typeof opt.fallbacks === 'object' ? opt.fallbacks : {}; // setting custom logger functions\n\n    logDebugFn = typeof opt.logDebugFn === 'function' ? opt.logDebugFn : debug;\n    logWarnFn = typeof opt.logWarnFn === 'function' ? opt.logWarnFn : warn;\n    logErrorFn = typeof opt.logErrorFn === 'function' ? opt.logErrorFn : error;\n    preserveLegacyCase = typeof opt.preserveLegacyCase === 'boolean' ? opt.preserveLegacyCase : true; // setting custom missing key function\n\n    missingKeyFn = typeof opt.missingKeyFn === 'function' ? opt.missingKeyFn : missingKey; // when missing locales we try to guess that from directory\n\n    opt.locales = opt.staticCatalog ? Object.keys(opt.staticCatalog) : opt.locales || guessLocales(directory); // some options should be disabled when using staticCatalog\n\n    if (opt.staticCatalog) {\n      updateFiles = false;\n      autoReload = false;\n      syncFiles = false;\n    } // customize mustache parsing\n\n\n    if (opt.mustacheConfig) {\n      if (Array.isArray(opt.mustacheConfig.tags)) {\n        mustacheConfig.tags = opt.mustacheConfig.tags;\n      }\n\n      if (opt.mustacheConfig.disable === true) {\n        mustacheConfig.disable = true;\n      }\n    }\n\n    const [start, end] = mustacheConfig.tags;\n    mustacheRegex = new RegExp(escapeRegExp(start) + '.*' + escapeRegExp(end)); // implicitly read all locales\n\n    if (Array.isArray(opt.locales)) {\n      if (opt.staticCatalog) {\n        locales = opt.staticCatalog;\n      } else {\n        opt.locales.forEach(function (l) {\n          read(l);\n        });\n      } // auto reload locale files when changed\n\n\n      if (autoReload) {\n        // watch changes of locale files (it's called twice because fs.watch is still unstable)\n        fs.watch(directory, function (event, filename) {\n          var localeFromFile = guessLocaleFromFile(filename);\n\n          if (localeFromFile && opt.locales.indexOf(localeFromFile) > -1) {\n            logDebug('Auto reloading locale file \"' + filename + '\".');\n            read(localeFromFile);\n          }\n        });\n      }\n    }\n  };\n\n  i18n.init = function i18nInit(request, response, next) {\n    if (typeof request === 'object') {\n      // guess requested language/locale\n      guessLanguage(request); // bind api to req\n\n      applyAPItoObject(request); // looks double but will ensure schema on api refactor\n\n      i18n.setLocale(request, request.locale);\n    } else {\n      return logError('i18n.init must be called with one parameter minimum, ie. i18n.init(req)');\n    }\n\n    if (typeof response === 'object') {\n      applyAPItoObject(response); // and set that locale to response too\n\n      i18n.setLocale(response, request.locale);\n    } // head over to next callback when bound as middleware\n\n\n    if (typeof next === 'function') {\n      return next();\n    }\n  };\n\n  i18n.__ = function i18nTranslate(phrase) {\n    var msg;\n    var argv = parseArgv(arguments);\n    var namedValues = argv[0];\n    var args = argv[1]; // called like __({phrase: \"Hello\", locale: \"en\"})\n\n    if (typeof phrase === 'object') {\n      if (typeof phrase.locale === 'string' && typeof phrase.phrase === 'string') {\n        msg = translate(phrase.locale, phrase.phrase);\n      }\n    } // called like __(\"Hello\")\n    else {\n        // get translated message with locale from scope (deprecated) or object\n        msg = translate(getLocaleFromObject(this), phrase);\n      } // postprocess to get compatible to plurals\n\n\n    if (typeof msg === 'object' && msg.one) {\n      msg = msg.one;\n    } // in case there is no 'one' but an 'other' rule\n\n\n    if (typeof msg === 'object' && msg.other) {\n      msg = msg.other;\n    } // head over to postProcessing\n\n\n    return postProcess(msg, namedValues, args);\n  };\n\n  i18n.__mf = function i18nMessageformat(phrase) {\n    var msg, mf, f;\n    var targetLocale = defaultLocale;\n    var argv = parseArgv(arguments);\n    var namedValues = argv[0];\n    var args = argv[1]; // called like __({phrase: \"Hello\", locale: \"en\"})\n\n    if (typeof phrase === 'object') {\n      if (typeof phrase.locale === 'string' && typeof phrase.phrase === 'string') {\n        msg = phrase.phrase;\n        targetLocale = phrase.locale;\n      }\n    } // called like __(\"Hello\")\n    else {\n        // get translated message with locale from scope (deprecated) or object\n        msg = phrase;\n        targetLocale = getLocaleFromObject(this);\n      }\n\n    msg = translate(targetLocale, msg); // --- end get msg\n    // now head over to Messageformat\n    // and try to cache instance\n\n    if (MessageformatInstanceForLocale[targetLocale]) {\n      mf = MessageformatInstanceForLocale[targetLocale];\n    } else {\n      mf = new Messageformat(targetLocale); // @see https://messageformat.github.io/messageformat/MessageFormat#disablePluralKeyChecks__anchor\n\n      mf.disablePluralKeyChecks();\n      mf.compiledFunctions = {};\n      MessageformatInstanceForLocale[targetLocale] = mf;\n    } // let's try to cache that function\n\n\n    if (mf.compiledFunctions[msg]) {\n      f = mf.compiledFunctions[msg];\n    } else {\n      f = mf.compile(msg);\n      mf.compiledFunctions[msg] = f;\n    }\n\n    return postProcess(f(namedValues), namedValues, args);\n  };\n\n  i18n.__l = function i18nTranslationList(phrase) {\n    var translations = [];\n    Object.keys(locales).sort().forEach(function (l) {\n      translations.push(i18n.__({\n        phrase: phrase,\n        locale: l\n      }));\n    });\n    return translations;\n  };\n\n  i18n.__h = function i18nTranslationHash(phrase) {\n    var translations = [];\n    Object.keys(locales).sort().forEach(function (l) {\n      var hash = {};\n      hash[l] = i18n.__({\n        phrase: phrase,\n        locale: l\n      });\n      translations.push(hash);\n    });\n    return translations;\n  };\n\n  i18n.__n = function i18nTranslatePlural(singular, plural, count) {\n    var msg;\n    var namedValues;\n    var targetLocale;\n    var args = []; // Accept an object with named values as the last parameter\n\n    if (argsEndWithNamedObject(arguments)) {\n      namedValues = arguments[arguments.length - 1];\n      args = arguments.length >= 5 ? Array.prototype.slice.call(arguments, 3, -1) : [];\n    } else {\n      namedValues = {};\n      args = arguments.length >= 4 ? Array.prototype.slice.call(arguments, 3) : [];\n    } // called like __n({singular: \"%s cat\", plural: \"%s cats\", locale: \"en\"}, 3)\n\n\n    if (typeof singular === 'object') {\n      if (typeof singular.locale === 'string' && typeof singular.singular === 'string' && typeof singular.plural === 'string') {\n        targetLocale = singular.locale;\n        msg = translate(singular.locale, singular.singular, singular.plural);\n      }\n\n      args.unshift(count); // some template engines pass all values as strings -> so we try to convert them to numbers\n\n      if (typeof plural === 'number' || Number(plural) + '' === plural) {\n        count = plural;\n      } // called like __n({singular: \"%s cat\", plural: \"%s cats\", locale: \"en\", count: 3})\n\n\n      if (typeof singular.count === 'number' || typeof singular.count === 'string') {\n        count = singular.count;\n        args.unshift(plural);\n      }\n    } else {\n      // called like  __n('cat', 3)\n      if (typeof plural === 'number' || Number(plural) + '' === plural) {\n        count = plural; // we add same string as default\n        // which efectivly copies the key to the plural.value\n        // this is for initialization of new empty translations\n\n        plural = singular;\n        args.unshift(count);\n        args.unshift(plural);\n      } // called like __n('%s cat', '%s cats', 3)\n      // get translated message with locale from scope (deprecated) or object\n\n\n      msg = translate(getLocaleFromObject(this), singular, plural);\n      targetLocale = getLocaleFromObject(this);\n    }\n\n    if (count === null) count = namedValues.count; // enforce number\n\n    count = Number(count); // find the correct plural rule for given locale\n\n    if (typeof msg === 'object') {\n      var p; // create a new Plural for locale\n      // and try to cache instance\n\n      if (PluralsForLocale[targetLocale]) {\n        p = PluralsForLocale[targetLocale];\n      } else {\n        // split locales with a region code\n        var lc = targetLocale.toLowerCase().split(/[_-\\s]+/).filter(function (el) {\n          return true && el;\n        }); // take the first part of locale, fallback to full locale\n\n        p = MakePlural[lc[0] || targetLocale];\n        PluralsForLocale[targetLocale] = p;\n      } // fallback to 'other' on case of missing translations\n\n\n      msg = msg[p(count)] || msg.other;\n    } // head over to postProcessing\n\n\n    return postProcess(msg, namedValues, args, count);\n  };\n\n  i18n.setLocale = function i18nSetLocale(object, locale, skipImplicitObjects) {\n    // when given an array of objects => setLocale on each\n    if (Array.isArray(object) && typeof locale === 'string') {\n      for (var i = object.length - 1; i >= 0; i--) {\n        i18n.setLocale(object[i], locale, true);\n      }\n\n      return i18n.getLocale(object[0]);\n    } // defaults to called like i18n.setLocale(req, 'en')\n\n\n    var targetObject = object;\n    var targetLocale = locale; // called like req.setLocale('en') or i18n.setLocale('en')\n\n    if (locale === undefined && typeof object === 'string') {\n      targetObject = this;\n      targetLocale = object;\n    } // consider a fallback\n\n\n    if (!locales[targetLocale]) {\n      targetLocale = getFallback(targetLocale, fallbacks) || targetLocale;\n    } // now set locale on object\n\n\n    targetObject.locale = locales[targetLocale] ? targetLocale : defaultLocale; // consider any extra registered objects\n\n    if (typeof register === 'object') {\n      if (Array.isArray(register) && !skipImplicitObjects) {\n        register.forEach(function (r) {\n          r.locale = targetObject.locale;\n        });\n      } else {\n        register.locale = targetObject.locale;\n      }\n    } // consider res\n\n\n    if (targetObject.res && !skipImplicitObjects) {\n      // escape recursion\n      // @see  - https://github.com/balderdashy/sails/pull/3631\n      //       - https://github.com/mashpie/i18n-node/pull/218\n      if (targetObject.res.locals) {\n        i18n.setLocale(targetObject.res, targetObject.locale, true);\n        i18n.setLocale(targetObject.res.locals, targetObject.locale, true);\n      } else {\n        i18n.setLocale(targetObject.res, targetObject.locale);\n      }\n    } // consider locals\n\n\n    if (targetObject.locals && !skipImplicitObjects) {\n      // escape recursion\n      // @see  - https://github.com/balderdashy/sails/pull/3631\n      //       - https://github.com/mashpie/i18n-node/pull/218\n      if (targetObject.locals.res) {\n        i18n.setLocale(targetObject.locals, targetObject.locale, true);\n        i18n.setLocale(targetObject.locals.res, targetObject.locale, true);\n      } else {\n        i18n.setLocale(targetObject.locals, targetObject.locale);\n      }\n    }\n\n    return i18n.getLocale(targetObject);\n  };\n\n  i18n.getLocale = function i18nGetLocale(request) {\n    // called like i18n.getLocale(req)\n    if (request && request.locale) {\n      return request.locale;\n    } // called like req.getLocale()\n\n\n    return this.locale || defaultLocale;\n  };\n\n  i18n.getCatalog = function i18nGetCatalog(object, locale) {\n    var targetLocale; // called like i18n.getCatalog(req)\n\n    if (typeof object === 'object' && typeof object.locale === 'string' && locale === undefined) {\n      targetLocale = object.locale;\n    } // called like i18n.getCatalog(req, 'en')\n\n\n    if (!targetLocale && typeof object === 'object' && typeof locale === 'string') {\n      targetLocale = locale;\n    } // called like req.getCatalog('en')\n\n\n    if (!targetLocale && locale === undefined && typeof object === 'string') {\n      targetLocale = object;\n    } // called like req.getCatalog()\n\n\n    if (!targetLocale && object === undefined && locale === undefined && typeof this.locale === 'string') {\n      if (register && register.global) {\n        targetLocale = '';\n      } else {\n        targetLocale = this.locale;\n      }\n    } // called like i18n.getCatalog()\n\n\n    if (targetLocale === undefined || targetLocale === '') {\n      return locales;\n    }\n\n    if (!locales[targetLocale]) {\n      targetLocale = getFallback(targetLocale, fallbacks) || targetLocale;\n    }\n\n    if (locales[targetLocale]) {\n      return locales[targetLocale];\n    } else {\n      logWarn('No catalog found for \"' + targetLocale + '\"');\n      return false;\n    }\n  };\n\n  i18n.getLocales = function i18nGetLocales() {\n    return Object.keys(locales);\n  };\n\n  i18n.addLocale = function i18nAddLocale(locale) {\n    read(locale);\n  };\n\n  i18n.removeLocale = function i18nRemoveLocale(locale) {\n    delete locales[locale];\n  }; // ===================\n  // = private methods =\n  // ===================\n\n\n  var postProcess = function (msg, namedValues, args, count) {\n    // test for parsable interval string\n    if (/\\|/.test(msg)) {\n      msg = parsePluralInterval(msg, count);\n    } // replace the counter\n\n\n    if (typeof count === 'number') {\n      msg = vsprintf(msg, [Number(count)]);\n    } // if the msg string contains {{Mustache}} patterns we render it as a mini tempalate\n\n\n    if (!mustacheConfig.disable && mustacheRegex.test(msg)) {\n      msg = Mustache.render(msg, namedValues, {}, mustacheConfig.tags);\n    } // if we have extra arguments with values to get replaced,\n    // an additional substition injects those strings afterwards\n\n\n    if (/%/.test(msg) && args && args.length > 0) {\n      msg = vsprintf(msg, args);\n    }\n\n    return msg;\n  };\n\n  var argsEndWithNamedObject = function (args) {\n    return args.length > 1 && args[args.length - 1] !== null && typeof args[args.length - 1] === 'object';\n  };\n\n  var parseArgv = function (args) {\n    var namedValues, returnArgs;\n\n    if (argsEndWithNamedObject(args)) {\n      namedValues = args[args.length - 1];\n      returnArgs = Array.prototype.slice.call(args, 1, -1);\n    } else {\n      namedValues = {};\n      returnArgs = args.length >= 2 ? Array.prototype.slice.call(args, 1) : [];\n    }\n\n    return [namedValues, returnArgs];\n  };\n  /**\n   * registers all public API methods to a given response object when not already declared\n   */\n\n\n  var applyAPItoObject = function (object) {\n    var alreadySetted = true; // attach to itself if not provided\n\n    for (var method in api) {\n      if (Object.prototype.hasOwnProperty.call(api, method)) {\n        var alias = api[method]; // be kind rewind, or better not touch anything already existing\n\n        if (!object[alias]) {\n          alreadySetted = false;\n          object[alias] = i18n[method].bind(object);\n        }\n      }\n    } // set initial locale if not set\n\n\n    if (!object.locale) {\n      object.locale = defaultLocale;\n    } // escape recursion\n\n\n    if (alreadySetted) {\n      return;\n    } // attach to response if present (ie. in express)\n\n\n    if (object.res) {\n      applyAPItoObject(object.res);\n    } // attach to locals if present (ie. in express)\n\n\n    if (object.locals) {\n      applyAPItoObject(object.locals);\n    }\n  };\n  /**\n   * tries to guess locales by scanning the given directory\n   */\n\n\n  var guessLocales = function (directory) {\n    var entries = fs.readdirSync(directory);\n    var localesFound = [];\n\n    for (var i = entries.length - 1; i >= 0; i--) {\n      if (entries[i].match(/^\\./)) continue;\n      var localeFromFile = guessLocaleFromFile(entries[i]);\n      if (localeFromFile) localesFound.push(localeFromFile);\n    }\n\n    return localesFound.sort();\n  };\n  /**\n   * tries to guess locales from a given filename\n   */\n\n\n  var guessLocaleFromFile = function (filename) {\n    var extensionRegex = new RegExp(extension + '$', 'g');\n    var prefixRegex = new RegExp('^' + prefix, 'g');\n    if (!filename) return false;\n    if (prefix && !filename.match(prefixRegex)) return false;\n    if (extension && !filename.match(extensionRegex)) return false;\n    return filename.replace(prefix, '').replace(extensionRegex, '');\n  };\n  /**\n   * @param queryLanguage - language query parameter, either an array or a string.\n   * @return the first non-empty language query parameter found, null otherwise.\n   */\n\n\n  var extractQueryLanguage = function (queryLanguage) {\n    if (Array.isArray(queryLanguage)) {\n      return queryLanguage.find(lang => lang !== '' && lang);\n    }\n\n    return typeof queryLanguage === 'string' && queryLanguage;\n  };\n  /**\n   * guess language setting based on http headers\n   */\n\n\n  var guessLanguage = function (request) {\n    if (typeof request === 'object') {\n      var languageHeader = request.headers ? request.headers[languageHeaderName] : undefined;\n      var languages = [];\n      var regions = [];\n      request.languages = [defaultLocale];\n      request.regions = [defaultLocale];\n      request.language = defaultLocale;\n      request.region = defaultLocale; // a query parameter overwrites all\n\n      if (queryParameter && request.url) {\n        var urlAsString = typeof request.url === 'string' ? request.url : request.url.toString();\n        /**\n         * @todo WHATWG new URL() requires full URL including hostname - that might change\n         * @see https://github.com/nodejs/node/issues/12682\n         */\n        // eslint-disable-next-line node/no-deprecated-api\n\n        var urlObj = url.parse(urlAsString, true);\n        var languageQueryParameter = urlObj.query[queryParameter];\n\n        if (languageQueryParameter) {\n          let queryLanguage = extractQueryLanguage(languageQueryParameter);\n\n          if (queryLanguage) {\n            logDebug('Overriding locale from query: ' + queryLanguage);\n\n            if (preserveLegacyCase) {\n              queryLanguage = queryLanguage.toLowerCase();\n            }\n\n            return i18n.setLocale(request, queryLanguage);\n          }\n        }\n      } // a cookie overwrites headers\n\n\n      if (cookiename && request.cookies && request.cookies[cookiename]) {\n        request.language = request.cookies[cookiename];\n        return i18n.setLocale(request, request.language);\n      } // 'accept-language' is the most common source\n\n\n      if (languageHeader) {\n        var acceptedLanguages = getAcceptedLanguagesFromHeader(languageHeader);\n        var match;\n        var fallbackMatch;\n        var fallback;\n\n        for (var i = 0; i < acceptedLanguages.length; i++) {\n          var lang = acceptedLanguages[i];\n          var lr = lang.split('-', 2);\n          var parentLang = lr[0];\n          var region = lr[1]; // Check if we have a configured fallback set for this language.\n\n          var fallbackLang = getFallback(lang, fallbacks);\n\n          if (fallbackLang) {\n            fallback = fallbackLang; // Fallbacks for languages should be inserted\n            // where the original, unsupported language existed.\n\n            var acceptedLanguageIndex = acceptedLanguages.indexOf(lang);\n            var fallbackIndex = acceptedLanguages.indexOf(fallback);\n\n            if (fallbackIndex > -1) {\n              acceptedLanguages.splice(fallbackIndex, 1);\n            }\n\n            acceptedLanguages.splice(acceptedLanguageIndex + 1, 0, fallback);\n          } // Check if we have a configured fallback set for the parent language of the locale.\n\n\n          var fallbackParentLang = getFallback(parentLang, fallbacks);\n\n          if (fallbackParentLang) {\n            fallback = fallbackParentLang; // Fallbacks for a parent language should be inserted\n            // to the end of the list, so they're only picked\n            // if there is no better match.\n\n            if (acceptedLanguages.indexOf(fallback) < 0) {\n              acceptedLanguages.push(fallback);\n            }\n          }\n\n          if (languages.indexOf(parentLang) < 0) {\n            languages.push(parentLang.toLowerCase());\n          }\n\n          if (region) {\n            regions.push(region.toLowerCase());\n          }\n\n          if (!match && locales[lang]) {\n            match = lang;\n            break;\n          }\n\n          if (!fallbackMatch && locales[parentLang]) {\n            fallbackMatch = parentLang;\n          }\n        }\n\n        request.language = match || fallbackMatch || request.language;\n        request.region = regions[0] || request.region;\n        return i18n.setLocale(request, request.language);\n      }\n    } // last resort: defaultLocale\n\n\n    return i18n.setLocale(request, defaultLocale);\n  };\n  /**\n   * Get a sorted list of accepted languages from the HTTP Accept-Language header\n   */\n\n\n  var getAcceptedLanguagesFromHeader = function (header) {\n    var languages = header.split(',');\n    var preferences = {};\n    return languages.map(function parseLanguagePreference(item) {\n      var preferenceParts = item.trim().split(';q=');\n\n      if (preferenceParts.length < 2) {\n        preferenceParts[1] = 1.0;\n      } else {\n        var quality = parseFloat(preferenceParts[1]);\n        preferenceParts[1] = quality || 0.0;\n      }\n\n      preferences[preferenceParts[0]] = preferenceParts[1];\n      return preferenceParts[0];\n    }).filter(function (lang) {\n      return preferences[lang] > 0;\n    }).sort(function sortLanguages(a, b) {\n      return preferences[b] - preferences[a];\n    });\n  };\n  /**\n   * searches for locale in given object\n   */\n\n\n  var getLocaleFromObject = function (obj) {\n    var locale;\n\n    if (obj && obj.scope) {\n      locale = obj.scope.locale;\n    }\n\n    if (obj && obj.locale) {\n      locale = obj.locale;\n    }\n\n    return locale;\n  };\n  /**\n   * splits and parses a phrase for mathematical interval expressions\n   */\n\n\n  var parsePluralInterval = function (phrase, count) {\n    var returnPhrase = phrase;\n    var phrases = phrase.split(/\\|/);\n    var intervalRuleExists = false; // some() breaks on 1st true\n\n    phrases.some(function (p) {\n      var matches = p.match(/^\\s*([()[\\]]+[\\d,]+[()[\\]]+)?\\s*(.*)$/); // not the same as in combined condition\n\n      if (matches != null && matches[1]) {\n        intervalRuleExists = true;\n\n        if (matchInterval(count, matches[1]) === true) {\n          returnPhrase = matches[2];\n          return true;\n        }\n      } else {\n        // this is a other or catch all case, this only is taken into account if there is actually another rule\n        if (intervalRuleExists) {\n          returnPhrase = p;\n        }\n      }\n    });\n    return returnPhrase;\n  };\n  /**\n   * test a number to match mathematical interval expressions\n   * [0,2] - 0 to 2 (including, matches: 0, 1, 2)\n   * ]0,3[ - 0 to 3 (excluding, matches: 1, 2)\n   * [1]   - 1 (matches: 1)\n   * [20,] - all numbers ≥20 (matches: 20, 21, 22, ...)\n   * [,20] - all numbers ≤20 (matches: 20, 21, 22, ...)\n   */\n\n\n  var matchInterval = function (number, interval) {\n    interval = parseInterval(interval);\n\n    if (interval && typeof number === 'number') {\n      if (interval.from.value === number) {\n        return interval.from.included;\n      }\n\n      if (interval.to.value === number) {\n        return interval.to.included;\n      }\n\n      return Math.min(interval.from.value, number) === interval.from.value && Math.max(interval.to.value, number) === interval.to.value;\n    }\n\n    return false;\n  };\n  /**\n   * read locale file, translate a msg and write to fs if new\n   */\n\n\n  var translate = function (locale, singular, plural, skipSyncToAllFiles) {\n    // add same key to all translations\n    if (!skipSyncToAllFiles && syncFiles) {\n      syncToAllFiles(singular, plural);\n    }\n\n    if (locale === undefined) {\n      logWarn('WARN: No locale found - check the context of the call to __(). Using ' + defaultLocale + ' as current locale');\n      locale = defaultLocale;\n    } // try to get a fallback\n\n\n    if (!locales[locale]) {\n      locale = getFallback(locale, fallbacks) || locale;\n    } // attempt to read when defined as valid locale\n\n\n    if (!locales[locale]) {\n      read(locale);\n    } // fallback to default when missed\n\n\n    if (!locales[locale]) {\n      logWarn('WARN: Locale ' + locale + \" couldn't be read - check the context of the call to $__. Using \" + defaultLocale + ' (default) as current locale');\n      locale = defaultLocale;\n      read(locale);\n    } // dotnotaction add on, @todo: factor out\n\n\n    var defaultSingular = singular;\n    var defaultPlural = plural;\n\n    if (objectNotation) {\n      var indexOfColon = singular.indexOf(':'); // We compare against 0 instead of -1 because\n      // we don't really expect the string to start with ':'.\n\n      if (indexOfColon > 0) {\n        defaultSingular = singular.substring(indexOfColon + 1);\n        singular = singular.substring(0, indexOfColon);\n      }\n\n      if (plural && typeof plural !== 'number') {\n        indexOfColon = plural.indexOf(':');\n\n        if (indexOfColon > 0) {\n          defaultPlural = plural.substring(indexOfColon + 1);\n          plural = plural.substring(0, indexOfColon);\n        }\n      }\n    }\n\n    var accessor = localeAccessor(locale, singular);\n    var mutator = localeMutator(locale, singular); // if (plural) {\n    //   if (accessor() == null) {\n    //     mutator({\n    //       'one': defaultSingular || singular,\n    //       'other': defaultPlural || plural\n    //     });\n    //     write(locale);\n    //   }\n    // }\n    // if (accessor() == null) {\n    //   mutator(defaultSingular || singular);\n    //   write(locale);\n    // }\n\n    if (plural) {\n      if (accessor() == null) {\n        // when retryInDefaultLocale is true - try to set default value from defaultLocale\n        if (retryInDefaultLocale && locale !== defaultLocale) {\n          logDebug('Missing ' + singular + ' in ' + locale + ' retrying in ' + defaultLocale);\n          mutator(translate(defaultLocale, singular, plural));\n        } else {\n          mutator({\n            one: defaultSingular || singular,\n            other: defaultPlural || plural\n          });\n        }\n\n        write(locale);\n      }\n    }\n\n    if (accessor() == null) {\n      // when retryInDefaultLocale is true - try to set default value from defaultLocale\n      if (retryInDefaultLocale && locale !== defaultLocale) {\n        logDebug('Missing ' + singular + ' in ' + locale + ' retrying in ' + defaultLocale);\n        mutator(translate(defaultLocale, singular, plural));\n      } else {\n        mutator(defaultSingular || singular);\n      }\n\n      write(locale);\n    }\n\n    return accessor();\n  };\n  /**\n   * initialize the same key in all locales\n   * when not already existing, checked via translate\n   */\n\n\n  var syncToAllFiles = function (singular, plural) {\n    // iterate over locales and translate again\n    // this will implicitly write/sync missing keys\n    // to the rest of locales\n    for (var l in locales) {\n      translate(l, singular, plural, true);\n    }\n  };\n  /**\n   * Allows delayed access to translations nested inside objects.\n   * @param {String} locale The locale to use.\n   * @param {String} singular The singular term to look up.\n   * @param {Boolean} [allowDelayedTraversal=true] Is delayed traversal of the tree allowed?\n   * This parameter is used internally. It allows to signal the accessor that\n   * a translation was not found in the initial lookup and that an invocation\n   * of the accessor may trigger another traversal of the tree.\n   * @returns {Function} A function that, when invoked, returns the current value stored\n   * in the object at the requested location.\n   */\n\n\n  var localeAccessor = function (locale, singular, allowDelayedTraversal) {\n    // Bail out on non-existent locales to defend against internal errors.\n    if (!locales[locale]) return Function.prototype; // Handle object lookup notation\n\n    var indexOfDot = objectNotation && singular.lastIndexOf(objectNotation);\n\n    if (objectNotation && indexOfDot > 0 && indexOfDot < singular.length - 1) {\n      // If delayed traversal wasn't specifically forbidden, it is allowed.\n      if (typeof allowDelayedTraversal === 'undefined') allowDelayedTraversal = true; // The accessor we're trying to find and which we want to return.\n\n      var accessor = null; // An accessor that returns null.\n\n      var nullAccessor = function () {\n        return null;\n      }; // Do we need to re-traverse the tree upon invocation of the accessor?\n\n\n      var reTraverse = false; // Split the provided term and run the callback for each subterm.\n\n      singular.split(objectNotation).reduce(function (object, index) {\n        // Make the accessor return null.\n        accessor = nullAccessor; // If our current target object (in the locale tree) doesn't exist or\n        // it doesn't have the next subterm as a member...\n\n        if (object === null || !Object.prototype.hasOwnProperty.call(object, index)) {\n          // ...remember that we need retraversal (because we didn't find our target).\n          reTraverse = allowDelayedTraversal; // Return null to avoid deeper iterations.\n\n          return null;\n        } // We can traverse deeper, so we generate an accessor for this current level.\n\n\n        accessor = function () {\n          return object[index];\n        }; // Return a reference to the next deeper level in the locale tree.\n\n\n        return object[index];\n      }, locales[locale]); // Return the requested accessor.\n\n      return function () {\n        // If we need to re-traverse (because we didn't find our target term)\n        // traverse again and return the new result (but don't allow further iterations)\n        // or return the previously found accessor if it was already valid.\n        return reTraverse ? localeAccessor(locale, singular, false)() : accessor();\n      };\n    } else {\n      // No object notation, just return an accessor that performs array lookup.\n      return function () {\n        return locales[locale][singular];\n      };\n    }\n  };\n  /**\n   * Allows delayed mutation of a translation nested inside objects.\n   * @description Construction of the mutator will attempt to locate the requested term\n   * inside the object, but if part of the branch does not exist yet, it will not be\n   * created until the mutator is actually invoked. At that point, re-traversal of the\n   * tree is performed and missing parts along the branch will be created.\n   * @param {String} locale The locale to use.\n   * @param {String} singular The singular term to look up.\n   * @param [Boolean} [allowBranching=false] Is the mutator allowed to create previously\n   * non-existent branches along the requested locale path?\n   * @returns {Function} A function that takes one argument. When the function is\n   * invoked, the targeted translation term will be set to the given value inside the locale table.\n   */\n\n\n  var localeMutator = function (locale, singular, allowBranching) {\n    // Bail out on non-existent locales to defend against internal errors.\n    if (!locales[locale]) return Function.prototype; // Handle object lookup notation\n\n    var indexOfDot = objectNotation && singular.lastIndexOf(objectNotation);\n\n    if (objectNotation && indexOfDot > 0 && indexOfDot < singular.length - 1) {\n      // If branching wasn't specifically allowed, disable it.\n      if (typeof allowBranching === 'undefined') allowBranching = false; // This will become the function we want to return.\n\n      var accessor = null; // An accessor that takes one argument and returns null.\n\n      var nullAccessor = function () {\n        return null;\n      }; // Fix object path.\n\n\n      var fixObject = function () {\n        return {};\n      }; // Are we going to need to re-traverse the tree when the mutator is invoked?\n\n\n      var reTraverse = false; // Split the provided term and run the callback for each subterm.\n\n      singular.split(objectNotation).reduce(function (object, index) {\n        // Make the mutator do nothing.\n        accessor = nullAccessor; // If our current target object (in the locale tree) doesn't exist or\n        // it doesn't have the next subterm as a member...\n\n        if (object === null || !Object.prototype.hasOwnProperty.call(object, index)) {\n          // ...check if we're allowed to create new branches.\n          if (allowBranching) {\n            // Fix `object` if `object` is not Object.\n            if (object === null || typeof object !== 'object') {\n              object = fixObject();\n            } // If we are allowed to, create a new object along the path.\n\n\n            object[index] = {};\n          } else {\n            // If we aren't allowed, remember that we need to re-traverse later on and...\n            reTraverse = true; // ...return null to make the next iteration bail our early on.\n\n            return null;\n          }\n        } // Generate a mutator for the current level.\n\n\n        accessor = function (value) {\n          object[index] = value;\n          return value;\n        }; // Generate a fixer for the current level.\n\n\n        fixObject = function () {\n          object[index] = {};\n          return object[index];\n        }; // Return a reference to the next deeper level in the locale tree.\n\n\n        return object[index];\n      }, locales[locale]); // Return the final mutator.\n\n      return function (value) {\n        // If we need to re-traverse the tree\n        // invoke the search again, but allow branching\n        // this time (because here the mutator is being invoked)\n        // otherwise, just change the value directly.\n        value = missingKeyFn(locale, value);\n        return reTraverse ? localeMutator(locale, singular, true)(value) : accessor(value);\n      };\n    } else {\n      // No object notation, just return a mutator that performs array lookup and changes the value.\n      return function (value) {\n        value = missingKeyFn(locale, value);\n        locales[locale][singular] = value;\n        return value;\n      };\n    }\n  };\n  /**\n   * try reading a file\n   */\n\n\n  var read = function (locale) {\n    var localeFile = {};\n    var file = getStorageFilePath(locale);\n\n    try {\n      logDebug('read ' + file + ' for locale: ' + locale);\n      localeFile = fs.readFileSync(file);\n\n      try {\n        // parsing filecontents to locales[locale]\n        locales[locale] = JSON.parse(localeFile);\n      } catch (parseError) {\n        logError('unable to parse locales from file (maybe ' + file + ' is empty or invalid json?): ', parseError);\n      }\n    } catch (readError) {\n      // unable to read, so intialize that file\n      // locales[locale] are already set in memory, so no extra read required\n      // or locales[locale] are empty, which initializes an empty locale.json file\n      // since the current invalid locale could exist, we should back it up\n      if (fs.existsSync(file)) {\n        logDebug('backing up invalid locale ' + locale + ' to ' + file + '.invalid');\n        fs.renameSync(file, file + '.invalid');\n      }\n\n      logDebug('initializing ' + file);\n      write(locale);\n    }\n  };\n  /**\n   * try writing a file in a created directory\n   */\n\n\n  var write = function (locale) {\n    var stats, target, tmp; // don't write new locale information to disk if updateFiles isn't true\n\n    if (!updateFiles) {\n      return;\n    } // creating directory if necessary\n\n\n    try {\n      stats = fs.lstatSync(directory);\n    } catch (e) {\n      logDebug('creating locales dir in: ' + directory);\n\n      try {\n        fs.mkdirSync(directory, directoryPermissions);\n      } catch (e) {\n        // in case of parallel tasks utilizing in same dir\n        if (e.code !== 'EEXIST') throw e;\n      }\n    } // first time init has an empty file\n\n\n    if (!locales[locale]) {\n      locales[locale] = {};\n    } // writing to tmp and rename on success\n\n\n    try {\n      target = getStorageFilePath(locale);\n      tmp = target + '.tmp';\n      fs.writeFileSync(tmp, JSON.stringify(locales[locale], null, indent), 'utf8');\n      stats = fs.statSync(tmp);\n\n      if (stats.isFile()) {\n        fs.renameSync(tmp, target);\n      } else {\n        logError('unable to write locales to file (either ' + tmp + ' or ' + target + ' are not writeable?): ');\n      }\n    } catch (e) {\n      logError('unexpected error writing files (either ' + tmp + ' or ' + target + ' are not writeable?): ', e);\n    }\n  };\n  /**\n   * basic normalization of filepath\n   */\n\n\n  var getStorageFilePath = function (locale) {\n    // changed API to use .json as default, #16\n    var ext = extension || '.json';\n    var filepath = path.normalize(directory + pathsep + prefix + locale + ext);\n    var filepathJS = path.normalize(directory + pathsep + prefix + locale + '.js'); // use .js as fallback if already existing\n\n    try {\n      if (fs.statSync(filepathJS)) {\n        logDebug('using existing file ' + filepathJS);\n        extension = '.js';\n        return filepathJS;\n      }\n    } catch (e) {\n      logDebug('will use ' + filepath);\n    }\n\n    return filepath;\n  };\n  /**\n   * Get locales with wildcard support\n   */\n\n\n  var getFallback = function (targetLocale, fallbacks) {\n    fallbacks = fallbacks || {};\n    if (fallbacks[targetLocale]) return fallbacks[targetLocale];\n    var fallBackLocale = null;\n\n    for (var key in fallbacks) {\n      if (targetLocale.match(new RegExp('^' + key.replace('*', '.*') + '$'))) {\n        fallBackLocale = fallbacks[key];\n        break;\n      }\n    }\n\n    return fallBackLocale;\n  };\n  /**\n   * Logging proxies\n   */\n\n\n  function logDebug(msg) {\n    logDebugFn(msg);\n  }\n\n  function logWarn(msg) {\n    logWarnFn(msg);\n  }\n\n  function logError(msg) {\n    logErrorFn(msg);\n  }\n  /**\n   * Missing key function\n   */\n\n\n  function missingKey(locale, value) {\n    return value;\n  }\n  /**\n   * implicitly configure when created with given options\n   * @example\n   * const i18n = new I18n({\n   *   locales: ['en', 'fr']\n   * });\n   */\n\n\n  if (_OPTS) i18n.configure(_OPTS);\n  return i18n;\n};\n\nmodule.exports = i18n;","map":{"version":3,"sources":["/home/prepelicamangalica/WorkspaceGit/SuperProjekt/src/main/ui/node_modules/i18n/i18n.js"],"names":["vsprintf","require","pkgVersion","version","fs","url","path","debug","warn","error","Mustache","Messageformat","MakePlural","parseInterval","default","escapeRegExp","string","replace","i18n","I18n","_OPTS","MessageformatInstanceForLocale","PluralsForLocale","locales","api","__","__n","__l","__h","__mf","getLocale","setLocale","getCatalog","getLocales","addLocale","removeLocale","mustacheConfig","tags","disable","mustacheRegex","pathsep","sep","autoReload","cookiename","languageHeaderName","defaultLocale","retryInDefaultLocale","directory","directoryPermissions","extension","fallbacks","indent","logDebugFn","logErrorFn","logWarnFn","preserveLegacyCase","objectNotation","prefix","queryParameter","register","updateFiles","syncFiles","missingKeyFn","configure","i18nConfigure","opt","method","Object","prototype","hasOwnProperty","call","alias","Array","isArray","forEach","r","applyAPItoObject","cookie","header","join","__dirname","parseInt","missingKey","staticCatalog","keys","guessLocales","start","end","RegExp","l","read","watch","event","filename","localeFromFile","guessLocaleFromFile","indexOf","logDebug","init","i18nInit","request","response","next","guessLanguage","locale","logError","i18nTranslate","phrase","msg","argv","parseArgv","arguments","namedValues","args","translate","getLocaleFromObject","one","other","postProcess","i18nMessageformat","mf","f","targetLocale","disablePluralKeyChecks","compiledFunctions","compile","i18nTranslationList","translations","sort","push","i18nTranslationHash","hash","i18nTranslatePlural","singular","plural","count","argsEndWithNamedObject","length","slice","unshift","Number","p","lc","toLowerCase","split","filter","el","i18nSetLocale","object","skipImplicitObjects","i","targetObject","undefined","getFallback","res","locals","i18nGetLocale","i18nGetCatalog","global","logWarn","i18nGetLocales","i18nAddLocale","i18nRemoveLocale","test","parsePluralInterval","render","returnArgs","alreadySetted","bind","entries","readdirSync","localesFound","match","extensionRegex","prefixRegex","extractQueryLanguage","queryLanguage","find","lang","languageHeader","headers","languages","regions","language","region","urlAsString","toString","urlObj","parse","languageQueryParameter","query","cookies","acceptedLanguages","getAcceptedLanguagesFromHeader","fallbackMatch","fallback","lr","parentLang","fallbackLang","acceptedLanguageIndex","fallbackIndex","splice","fallbackParentLang","preferences","map","parseLanguagePreference","item","preferenceParts","trim","quality","parseFloat","sortLanguages","a","b","obj","scope","returnPhrase","phrases","intervalRuleExists","some","matches","matchInterval","number","interval","from","value","included","to","Math","min","max","skipSyncToAllFiles","syncToAllFiles","defaultSingular","defaultPlural","indexOfColon","substring","accessor","localeAccessor","mutator","localeMutator","write","allowDelayedTraversal","Function","indexOfDot","lastIndexOf","nullAccessor","reTraverse","reduce","index","allowBranching","fixObject","localeFile","file","getStorageFilePath","readFileSync","JSON","parseError","readError","existsSync","renameSync","stats","target","tmp","lstatSync","e","mkdirSync","code","writeFileSync","stringify","statSync","isFile","ext","filepath","normalize","filepathJS","fallBackLocale","key","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,a,CAEA;;AACA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,YAAD,CAAP,CAAsBD,QAArC;;AACA,IAAIE,UAAU,GAAGD,OAAO,CAAC,gBAAD,CAAP,CAA0BE,OAA3C;;AACA,IAAIC,EAAE,GAAGH,OAAO,CAAC,IAAD,CAAhB;;AACA,IAAII,GAAG,GAAGJ,OAAO,CAAC,KAAD,CAAjB;;AACA,IAAIK,IAAI,GAAGL,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIM,KAAK,GAAGN,OAAO,CAAC,OAAD,CAAP,CAAiB,YAAjB,CAAZ;;AACA,IAAIO,IAAI,GAAGP,OAAO,CAAC,OAAD,CAAP,CAAiB,WAAjB,CAAX;;AACA,IAAIQ,KAAK,GAAGR,OAAO,CAAC,OAAD,CAAP,CAAiB,YAAjB,CAAZ;;AACA,IAAIS,QAAQ,GAAGT,OAAO,CAAC,UAAD,CAAtB;;AACA,IAAIU,aAAa,GAAGV,OAAO,CAAC,eAAD,CAA3B;;AACA,IAAIW,UAAU,GAAGX,OAAO,CAAC,aAAD,CAAxB;;AACA,IAAIY,aAAa,GAAGZ,OAAO,CAAC,sBAAD,CAAP,CAAgCa,OAApD,C,CAEA;;;AACA,IAAIC,YAAY,GAAG,UAAUC,MAAV,EAAkB;AACnC,SAAOA,MAAM,CAACC,OAAP,CAAe,qBAAf,EAAsC,MAAtC,CAAP,CADmC,CACkB;AACtD,CAFD,C,CAIA;;;AACA,MAAMC,IAAI,GAAG,SAASC,IAAT,CAAcC,KAAK,GAAG,KAAtB,EAA6B;AACxC,MAAIC,8BAA8B,GAAG,EAArC;AACA,MAAIC,gBAAgB,GAAG,EAAvB;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,GAAG,GAAG;AACRC,IAAAA,EAAE,EAAE,IADI;AAERC,IAAAA,GAAG,EAAE,KAFG;AAGRC,IAAAA,GAAG,EAAE,KAHG;AAIRC,IAAAA,GAAG,EAAE,KAJG;AAKRC,IAAAA,IAAI,EAAE,MALE;AAMRC,IAAAA,SAAS,EAAE,WANH;AAORC,IAAAA,SAAS,EAAE,WAPH;AAQRC,IAAAA,UAAU,EAAE,YARJ;AASRC,IAAAA,UAAU,EAAE,YATJ;AAURC,IAAAA,SAAS,EAAE,WAVH;AAWRC,IAAAA,YAAY,EAAE;AAXN,GAAV;AAaA,MAAIC,cAAc,GAAG;AACnBC,IAAAA,IAAI,EAAE,CAAC,IAAD,EAAO,IAAP,CADa;AAEnBC,IAAAA,OAAO,EAAE;AAFU,GAArB;AAIA,MAAIC,aAAJ;AACA,MAAIC,OAAO,GAAGlC,IAAI,CAACmC,GAAnB,CAtBwC,CAsBjB;;AACvB,MAAIC,UAAJ;AACA,MAAIC,UAAJ;AACA,MAAIC,kBAAJ;AACA,MAAIC,aAAJ;AACA,MAAIC,oBAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,oBAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,MAAJ;AACA,MAAIC,UAAJ;AACA,MAAIC,UAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,kBAAJ;AACA,MAAIC,cAAJ;AACA,MAAIC,MAAJ;AACA,MAAIC,cAAJ;AACA,MAAIC,QAAJ;AACA,MAAIC,WAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,YAAJ,CA3CwC,CA6CxC;;AACA,MAAI5C,IAAI,GAAG,EAAX;AAEAA,EAAAA,IAAI,CAACf,OAAL,GAAeD,UAAf;;AAEAgB,EAAAA,IAAI,CAAC6C,SAAL,GAAiB,SAASC,aAAT,CAAuBC,GAAvB,EAA4B;AAC3C;AACA1C,IAAAA,OAAO,GAAG,EAAV,CAF2C,CAI3C;AACA;;AACA,QAAI0C,GAAG,CAACzC,GAAJ,IAAW,OAAOyC,GAAG,CAACzC,GAAX,KAAmB,QAAlC,EAA4C;AAC1C,WAAK,IAAI0C,MAAT,IAAmBD,GAAG,CAACzC,GAAvB,EAA4B;AAC1B,YAAI2C,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,GAAG,CAACzC,GAAzC,EAA8C0C,MAA9C,CAAJ,EAA2D;AACzD,cAAIK,KAAK,GAAGN,GAAG,CAACzC,GAAJ,CAAQ0C,MAAR,CAAZ;;AACA,cAAI,OAAO1C,GAAG,CAAC0C,MAAD,CAAV,KAAuB,WAA3B,EAAwC;AACtC1C,YAAAA,GAAG,CAAC0C,MAAD,CAAH,GAAcK,KAAd;AACD;AACF;AACF;AACF,KAf0C,CAiB3C;;;AACA,QAAI,OAAON,GAAG,CAACN,QAAX,KAAwB,QAA5B,EAAsC;AACpCA,MAAAA,QAAQ,GAAGM,GAAG,CAACN,QAAf,CADoC,CAEpC;;AACA,UAAIa,KAAK,CAACC,OAAN,CAAcR,GAAG,CAACN,QAAlB,CAAJ,EAAiC;AAC/BA,QAAAA,QAAQ,GAAGM,GAAG,CAACN,QAAf;AACAA,QAAAA,QAAQ,CAACe,OAAT,CAAiB,UAAUC,CAAV,EAAa;AAC5BC,UAAAA,gBAAgB,CAACD,CAAD,CAAhB;AACD,SAFD;AAGD,OALD,MAKO;AACLC,QAAAA,gBAAgB,CAACX,GAAG,CAACN,QAAL,CAAhB;AACD;AACF,KA7B0C,CA+B3C;;;AACAhB,IAAAA,UAAU,GAAG,OAAOsB,GAAG,CAACY,MAAX,KAAsB,QAAtB,GAAiCZ,GAAG,CAACY,MAArC,GAA8C,IAA3D,CAhC2C,CAkC3C;;AACAjC,IAAAA,kBAAkB,GAChB,OAAOqB,GAAG,CAACa,MAAX,KAAsB,QAAtB,GAAiCb,GAAG,CAACa,MAArC,GAA8C,iBADhD,CAnC2C,CAsC3C;;AACApB,IAAAA,cAAc,GACZ,OAAOO,GAAG,CAACP,cAAX,KAA8B,QAA9B,GAAyCO,GAAG,CAACP,cAA7C,GAA8D,IADhE,CAvC2C,CA0C3C;;AACAX,IAAAA,SAAS,GACP,OAAOkB,GAAG,CAAClB,SAAX,KAAyB,QAAzB,GACIkB,GAAG,CAAClB,SADR,GAEIzC,IAAI,CAACyE,IAAL,CAAUC,SAAV,EAAqB,SAArB,CAHN,CA3C2C,CAgD3C;;AACAhC,IAAAA,oBAAoB,GAClB,OAAOiB,GAAG,CAACjB,oBAAX,KAAoC,QAApC,GACIiC,QAAQ,CAAChB,GAAG,CAACjB,oBAAL,EAA2B,CAA3B,CADZ,GAEI,IAHN,CAjD2C,CAsD3C;;AACAY,IAAAA,WAAW,GAAG,OAAOK,GAAG,CAACL,WAAX,KAA2B,SAA3B,GAAuCK,GAAG,CAACL,WAA3C,GAAyD,IAAvE,CAvD2C,CAyD3C;;AACAC,IAAAA,SAAS,GAAG,OAAOI,GAAG,CAACJ,SAAX,KAAyB,SAAzB,GAAqCI,GAAG,CAACJ,SAAzC,GAAqD,KAAjE,CA1D2C,CA4D3C;;AACAV,IAAAA,MAAM,GAAG,OAAOc,GAAG,CAACd,MAAX,KAAsB,QAAtB,GAAiCc,GAAG,CAACd,MAArC,GAA8C,IAAvD,CA7D2C,CA+D3C;;AACAM,IAAAA,MAAM,GAAG,OAAOQ,GAAG,CAACR,MAAX,KAAsB,QAAtB,GAAiCQ,GAAG,CAACR,MAArC,GAA8C,EAAvD,CAhE2C,CAkE3C;;AACAR,IAAAA,SAAS,GAAG,OAAOgB,GAAG,CAAChB,SAAX,KAAyB,QAAzB,GAAoCgB,GAAG,CAAChB,SAAxC,GAAoD,OAAhE,CAnE2C,CAqE3C;;AACAJ,IAAAA,aAAa,GACX,OAAOoB,GAAG,CAACpB,aAAX,KAA6B,QAA7B,GAAwCoB,GAAG,CAACpB,aAA5C,GAA4D,IAD9D,CAtE2C,CAyE3C;;AACAC,IAAAA,oBAAoB,GAClB,OAAOmB,GAAG,CAACnB,oBAAX,KAAoC,SAApC,GACImB,GAAG,CAACnB,oBADR,GAEI,KAHN,CA1E2C,CA+E3C;;AACAJ,IAAAA,UAAU,GAAG,OAAOuB,GAAG,CAACvB,UAAX,KAA0B,SAA1B,GAAsCuB,GAAG,CAACvB,UAA1C,GAAuD,KAApE,CAhF2C,CAkF3C;;AACAc,IAAAA,cAAc,GACZ,OAAOS,GAAG,CAACT,cAAX,KAA8B,WAA9B,GAA4CS,GAAG,CAACT,cAAhD,GAAiE,KADnE;AAEA,QAAIA,cAAc,KAAK,IAAvB,EAA6BA,cAAc,GAAG,GAAjB,CArFc,CAuF3C;;AACAN,IAAAA,SAAS,GAAG,OAAOe,GAAG,CAACf,SAAX,KAAyB,QAAzB,GAAoCe,GAAG,CAACf,SAAxC,GAAoD,EAAhE,CAxF2C,CA0F3C;;AACAE,IAAAA,UAAU,GAAG,OAAOa,GAAG,CAACb,UAAX,KAA0B,UAA1B,GAAuCa,GAAG,CAACb,UAA3C,GAAwD7C,KAArE;AACA+C,IAAAA,SAAS,GAAG,OAAOW,GAAG,CAACX,SAAX,KAAyB,UAAzB,GAAsCW,GAAG,CAACX,SAA1C,GAAsD9C,IAAlE;AACA6C,IAAAA,UAAU,GAAG,OAAOY,GAAG,CAACZ,UAAX,KAA0B,UAA1B,GAAuCY,GAAG,CAACZ,UAA3C,GAAwD5C,KAArE;AAEA8C,IAAAA,kBAAkB,GAChB,OAAOU,GAAG,CAACV,kBAAX,KAAkC,SAAlC,GACIU,GAAG,CAACV,kBADR,GAEI,IAHN,CA/F2C,CAoG3C;;AACAO,IAAAA,YAAY,GACV,OAAOG,GAAG,CAACH,YAAX,KAA4B,UAA5B,GAAyCG,GAAG,CAACH,YAA7C,GAA4DoB,UAD9D,CArG2C,CAwG3C;;AACAjB,IAAAA,GAAG,CAAC1C,OAAJ,GAAc0C,GAAG,CAACkB,aAAJ,GACVhB,MAAM,CAACiB,IAAP,CAAYnB,GAAG,CAACkB,aAAhB,CADU,GAEVlB,GAAG,CAAC1C,OAAJ,IAAe8D,YAAY,CAACtC,SAAD,CAF/B,CAzG2C,CA6G3C;;AACA,QAAIkB,GAAG,CAACkB,aAAR,EAAuB;AACrBvB,MAAAA,WAAW,GAAG,KAAd;AACAlB,MAAAA,UAAU,GAAG,KAAb;AACAmB,MAAAA,SAAS,GAAG,KAAZ;AACD,KAlH0C,CAoH3C;;;AACA,QAAII,GAAG,CAAC7B,cAAR,EAAwB;AACtB,UAAIoC,KAAK,CAACC,OAAN,CAAcR,GAAG,CAAC7B,cAAJ,CAAmBC,IAAjC,CAAJ,EAA4C;AAC1CD,QAAAA,cAAc,CAACC,IAAf,GAAsB4B,GAAG,CAAC7B,cAAJ,CAAmBC,IAAzC;AACD;;AACD,UAAI4B,GAAG,CAAC7B,cAAJ,CAAmBE,OAAnB,KAA+B,IAAnC,EAAyC;AACvCF,QAAAA,cAAc,CAACE,OAAf,GAAyB,IAAzB;AACD;AACF;;AAED,UAAM,CAACgD,KAAD,EAAQC,GAAR,IAAenD,cAAc,CAACC,IAApC;AACAE,IAAAA,aAAa,GAAG,IAAIiD,MAAJ,CAAWzE,YAAY,CAACuE,KAAD,CAAZ,GAAsB,IAAtB,GAA6BvE,YAAY,CAACwE,GAAD,CAApD,CAAhB,CA/H2C,CAiI3C;;AACA,QAAIf,KAAK,CAACC,OAAN,CAAcR,GAAG,CAAC1C,OAAlB,CAAJ,EAAgC;AAC9B,UAAI0C,GAAG,CAACkB,aAAR,EAAuB;AACrB5D,QAAAA,OAAO,GAAG0C,GAAG,CAACkB,aAAd;AACD,OAFD,MAEO;AACLlB,QAAAA,GAAG,CAAC1C,OAAJ,CAAYmD,OAAZ,CAAoB,UAAUe,CAAV,EAAa;AAC/BC,UAAAA,IAAI,CAACD,CAAD,CAAJ;AACD,SAFD;AAGD,OAP6B,CAS9B;;;AACA,UAAI/C,UAAJ,EAAgB;AACd;AACAtC,QAAAA,EAAE,CAACuF,KAAH,CAAS5C,SAAT,EAAoB,UAAU6C,KAAV,EAAiBC,QAAjB,EAA2B;AAC7C,cAAIC,cAAc,GAAGC,mBAAmB,CAACF,QAAD,CAAxC;;AAEA,cAAIC,cAAc,IAAI7B,GAAG,CAAC1C,OAAJ,CAAYyE,OAAZ,CAAoBF,cAApB,IAAsC,CAAC,CAA7D,EAAgE;AAC9DG,YAAAA,QAAQ,CAAC,iCAAiCJ,QAAjC,GAA4C,IAA7C,CAAR;AACAH,YAAAA,IAAI,CAACI,cAAD,CAAJ;AACD;AACF,SAPD;AAQD;AACF;AACF,GAxJD;;AA0JA5E,EAAAA,IAAI,CAACgF,IAAL,GAAY,SAASC,QAAT,CAAkBC,OAAlB,EAA2BC,QAA3B,EAAqCC,IAArC,EAA2C;AACrD,QAAI,OAAOF,OAAP,KAAmB,QAAvB,EAAiC;AAC/B;AACAG,MAAAA,aAAa,CAACH,OAAD,CAAb,CAF+B,CAI/B;;AACAxB,MAAAA,gBAAgB,CAACwB,OAAD,CAAhB,CAL+B,CAO/B;;AACAlF,MAAAA,IAAI,CAACa,SAAL,CAAeqE,OAAf,EAAwBA,OAAO,CAACI,MAAhC;AACD,KATD,MASO;AACL,aAAOC,QAAQ,CACb,yEADa,CAAf;AAGD;;AAED,QAAI,OAAOJ,QAAP,KAAoB,QAAxB,EAAkC;AAChCzB,MAAAA,gBAAgB,CAACyB,QAAD,CAAhB,CADgC,CAGhC;;AACAnF,MAAAA,IAAI,CAACa,SAAL,CAAesE,QAAf,EAAyBD,OAAO,CAACI,MAAjC;AACD,KArBoD,CAuBrD;;;AACA,QAAI,OAAOF,IAAP,KAAgB,UAApB,EAAgC;AAC9B,aAAOA,IAAI,EAAX;AACD;AACF,GA3BD;;AA6BApF,EAAAA,IAAI,CAACO,EAAL,GAAU,SAASiF,aAAT,CAAuBC,MAAvB,EAA+B;AACvC,QAAIC,GAAJ;AACA,QAAIC,IAAI,GAAGC,SAAS,CAACC,SAAD,CAApB;AACA,QAAIC,WAAW,GAAGH,IAAI,CAAC,CAAD,CAAtB;AACA,QAAII,IAAI,GAAGJ,IAAI,CAAC,CAAD,CAAf,CAJuC,CAMvC;;AACA,QAAI,OAAOF,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,UACE,OAAOA,MAAM,CAACH,MAAd,KAAyB,QAAzB,IACA,OAAOG,MAAM,CAACA,MAAd,KAAyB,QAF3B,EAGE;AACAC,QAAAA,GAAG,GAAGM,SAAS,CAACP,MAAM,CAACH,MAAR,EAAgBG,MAAM,CAACA,MAAvB,CAAf;AACD;AACF,KAPD,CAQA;AARA,SASK;AACH;AACAC,QAAAA,GAAG,GAAGM,SAAS,CAACC,mBAAmB,CAAC,IAAD,CAApB,EAA4BR,MAA5B,CAAf;AACD,OAnBsC,CAqBvC;;;AACA,QAAI,OAAOC,GAAP,KAAe,QAAf,IAA2BA,GAAG,CAACQ,GAAnC,EAAwC;AACtCR,MAAAA,GAAG,GAAGA,GAAG,CAACQ,GAAV;AACD,KAxBsC,CA0BvC;;;AACA,QAAI,OAAOR,GAAP,KAAe,QAAf,IAA2BA,GAAG,CAACS,KAAnC,EAA0C;AACxCT,MAAAA,GAAG,GAAGA,GAAG,CAACS,KAAV;AACD,KA7BsC,CA+BvC;;;AACA,WAAOC,WAAW,CAACV,GAAD,EAAMI,WAAN,EAAmBC,IAAnB,CAAlB;AACD,GAjCD;;AAmCA/F,EAAAA,IAAI,CAACW,IAAL,GAAY,SAAS0F,iBAAT,CAA2BZ,MAA3B,EAAmC;AAC7C,QAAIC,GAAJ,EAASY,EAAT,EAAaC,CAAb;AACA,QAAIC,YAAY,GAAG7E,aAAnB;AACA,QAAIgE,IAAI,GAAGC,SAAS,CAACC,SAAD,CAApB;AACA,QAAIC,WAAW,GAAGH,IAAI,CAAC,CAAD,CAAtB;AACA,QAAII,IAAI,GAAGJ,IAAI,CAAC,CAAD,CAAf,CAL6C,CAO7C;;AACA,QAAI,OAAOF,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,UACE,OAAOA,MAAM,CAACH,MAAd,KAAyB,QAAzB,IACA,OAAOG,MAAM,CAACA,MAAd,KAAyB,QAF3B,EAGE;AACAC,QAAAA,GAAG,GAAGD,MAAM,CAACA,MAAb;AACAe,QAAAA,YAAY,GAAGf,MAAM,CAACH,MAAtB;AACD;AACF,KARD,CASA;AATA,SAUK;AACH;AACAI,QAAAA,GAAG,GAAGD,MAAN;AACAe,QAAAA,YAAY,GAAGP,mBAAmB,CAAC,IAAD,CAAlC;AACD;;AAEDP,IAAAA,GAAG,GAAGM,SAAS,CAACQ,YAAD,EAAed,GAAf,CAAf,CAxB6C,CAyB7C;AAEA;AACA;;AACA,QAAIvF,8BAA8B,CAACqG,YAAD,CAAlC,EAAkD;AAChDF,MAAAA,EAAE,GAAGnG,8BAA8B,CAACqG,YAAD,CAAnC;AACD,KAFD,MAEO;AACLF,MAAAA,EAAE,GAAG,IAAI7G,aAAJ,CAAkB+G,YAAlB,CAAL,CADK,CAGL;;AACAF,MAAAA,EAAE,CAACG,sBAAH;AACAH,MAAAA,EAAE,CAACI,iBAAH,GAAuB,EAAvB;AACAvG,MAAAA,8BAA8B,CAACqG,YAAD,CAA9B,GAA+CF,EAA/C;AACD,KAtC4C,CAwC7C;;;AACA,QAAIA,EAAE,CAACI,iBAAH,CAAqBhB,GAArB,CAAJ,EAA+B;AAC7Ba,MAAAA,CAAC,GAAGD,EAAE,CAACI,iBAAH,CAAqBhB,GAArB,CAAJ;AACD,KAFD,MAEO;AACLa,MAAAA,CAAC,GAAGD,EAAE,CAACK,OAAH,CAAWjB,GAAX,CAAJ;AACAY,MAAAA,EAAE,CAACI,iBAAH,CAAqBhB,GAArB,IAA4Ba,CAA5B;AACD;;AAED,WAAOH,WAAW,CAACG,CAAC,CAACT,WAAD,CAAF,EAAiBA,WAAjB,EAA8BC,IAA9B,CAAlB;AACD,GAjDD;;AAmDA/F,EAAAA,IAAI,CAACS,GAAL,GAAW,SAASmG,mBAAT,CAA6BnB,MAA7B,EAAqC;AAC9C,QAAIoB,YAAY,GAAG,EAAnB;AACA5D,IAAAA,MAAM,CAACiB,IAAP,CAAY7D,OAAZ,EACGyG,IADH,GAEGtD,OAFH,CAEW,UAAUe,CAAV,EAAa;AACpBsC,MAAAA,YAAY,CAACE,IAAb,CAAkB/G,IAAI,CAACO,EAAL,CAAQ;AAAEkF,QAAAA,MAAM,EAAEA,MAAV;AAAkBH,QAAAA,MAAM,EAAEf;AAA1B,OAAR,CAAlB;AACD,KAJH;AAKA,WAAOsC,YAAP;AACD,GARD;;AAUA7G,EAAAA,IAAI,CAACU,GAAL,GAAW,SAASsG,mBAAT,CAA6BvB,MAA7B,EAAqC;AAC9C,QAAIoB,YAAY,GAAG,EAAnB;AACA5D,IAAAA,MAAM,CAACiB,IAAP,CAAY7D,OAAZ,EACGyG,IADH,GAEGtD,OAFH,CAEW,UAAUe,CAAV,EAAa;AACpB,UAAI0C,IAAI,GAAG,EAAX;AACAA,MAAAA,IAAI,CAAC1C,CAAD,CAAJ,GAAUvE,IAAI,CAACO,EAAL,CAAQ;AAAEkF,QAAAA,MAAM,EAAEA,MAAV;AAAkBH,QAAAA,MAAM,EAAEf;AAA1B,OAAR,CAAV;AACAsC,MAAAA,YAAY,CAACE,IAAb,CAAkBE,IAAlB;AACD,KANH;AAOA,WAAOJ,YAAP;AACD,GAVD;;AAYA7G,EAAAA,IAAI,CAACQ,GAAL,GAAW,SAAS0G,mBAAT,CAA6BC,QAA7B,EAAuCC,MAAvC,EAA+CC,KAA/C,EAAsD;AAC/D,QAAI3B,GAAJ;AACA,QAAII,WAAJ;AACA,QAAIU,YAAJ;AACA,QAAIT,IAAI,GAAG,EAAX,CAJ+D,CAM/D;;AACA,QAAIuB,sBAAsB,CAACzB,SAAD,CAA1B,EAAuC;AACrCC,MAAAA,WAAW,GAAGD,SAAS,CAACA,SAAS,CAAC0B,MAAV,GAAmB,CAApB,CAAvB;AACAxB,MAAAA,IAAI,GACFF,SAAS,CAAC0B,MAAV,IAAoB,CAApB,GACIjE,KAAK,CAACJ,SAAN,CAAgBsE,KAAhB,CAAsBpE,IAAtB,CAA2ByC,SAA3B,EAAsC,CAAtC,EAAyC,CAAC,CAA1C,CADJ,GAEI,EAHN;AAID,KAND,MAMO;AACLC,MAAAA,WAAW,GAAG,EAAd;AACAC,MAAAA,IAAI,GACFF,SAAS,CAAC0B,MAAV,IAAoB,CAApB,GAAwBjE,KAAK,CAACJ,SAAN,CAAgBsE,KAAhB,CAAsBpE,IAAtB,CAA2ByC,SAA3B,EAAsC,CAAtC,CAAxB,GAAmE,EADrE;AAED,KAjB8D,CAmB/D;;;AACA,QAAI,OAAOsB,QAAP,KAAoB,QAAxB,EAAkC;AAChC,UACE,OAAOA,QAAQ,CAAC7B,MAAhB,KAA2B,QAA3B,IACA,OAAO6B,QAAQ,CAACA,QAAhB,KAA6B,QAD7B,IAEA,OAAOA,QAAQ,CAACC,MAAhB,KAA2B,QAH7B,EAIE;AACAZ,QAAAA,YAAY,GAAGW,QAAQ,CAAC7B,MAAxB;AACAI,QAAAA,GAAG,GAAGM,SAAS,CAACmB,QAAQ,CAAC7B,MAAV,EAAkB6B,QAAQ,CAACA,QAA3B,EAAqCA,QAAQ,CAACC,MAA9C,CAAf;AACD;;AACDrB,MAAAA,IAAI,CAAC0B,OAAL,CAAaJ,KAAb,EATgC,CAWhC;;AACA,UAAI,OAAOD,MAAP,KAAkB,QAAlB,IAA8BM,MAAM,CAACN,MAAD,CAAN,GAAiB,EAAjB,KAAwBA,MAA1D,EAAkE;AAChEC,QAAAA,KAAK,GAAGD,MAAR;AACD,OAd+B,CAgBhC;;;AACA,UACE,OAAOD,QAAQ,CAACE,KAAhB,KAA0B,QAA1B,IACA,OAAOF,QAAQ,CAACE,KAAhB,KAA0B,QAF5B,EAGE;AACAA,QAAAA,KAAK,GAAGF,QAAQ,CAACE,KAAjB;AACAtB,QAAAA,IAAI,CAAC0B,OAAL,CAAaL,MAAb;AACD;AACF,KAxBD,MAwBO;AACL;AACA,UAAI,OAAOA,MAAP,KAAkB,QAAlB,IAA8BM,MAAM,CAACN,MAAD,CAAN,GAAiB,EAAjB,KAAwBA,MAA1D,EAAkE;AAChEC,QAAAA,KAAK,GAAGD,MAAR,CADgE,CAGhE;AACA;AACA;;AACAA,QAAAA,MAAM,GAAGD,QAAT;AAEApB,QAAAA,IAAI,CAAC0B,OAAL,CAAaJ,KAAb;AACAtB,QAAAA,IAAI,CAAC0B,OAAL,CAAaL,MAAb;AACD,OAZI,CAaL;AACA;;;AACA1B,MAAAA,GAAG,GAAGM,SAAS,CAACC,mBAAmB,CAAC,IAAD,CAApB,EAA4BkB,QAA5B,EAAsCC,MAAtC,CAAf;AACAZ,MAAAA,YAAY,GAAGP,mBAAmB,CAAC,IAAD,CAAlC;AACD;;AAED,QAAIoB,KAAK,KAAK,IAAd,EAAoBA,KAAK,GAAGvB,WAAW,CAACuB,KAApB,CA/D2C,CAiE/D;;AACAA,IAAAA,KAAK,GAAGK,MAAM,CAACL,KAAD,CAAd,CAlE+D,CAoE/D;;AACA,QAAI,OAAO3B,GAAP,KAAe,QAAnB,EAA6B;AAC3B,UAAIiC,CAAJ,CAD2B,CAE3B;AACA;;AACA,UAAIvH,gBAAgB,CAACoG,YAAD,CAApB,EAAoC;AAClCmB,QAAAA,CAAC,GAAGvH,gBAAgB,CAACoG,YAAD,CAApB;AACD,OAFD,MAEO;AACL;AACA,YAAIoB,EAAE,GAAGpB,YAAY,CAClBqB,WADM,GAENC,KAFM,CAEA,SAFA,EAGNC,MAHM,CAGC,UAAUC,EAAV,EAAc;AACpB,iBAAO,QAAQA,EAAf;AACD,SALM,CAAT,CAFK,CAQL;;AACAL,QAAAA,CAAC,GAAGjI,UAAU,CAACkI,EAAE,CAAC,CAAD,CAAF,IAASpB,YAAV,CAAd;AACApG,QAAAA,gBAAgB,CAACoG,YAAD,CAAhB,GAAiCmB,CAAjC;AACD,OAjB0B,CAmB3B;;;AACAjC,MAAAA,GAAG,GAAGA,GAAG,CAACiC,CAAC,CAACN,KAAD,CAAF,CAAH,IAAiB3B,GAAG,CAACS,KAA3B;AACD,KA1F8D,CA4F/D;;;AACA,WAAOC,WAAW,CAACV,GAAD,EAAMI,WAAN,EAAmBC,IAAnB,EAAyBsB,KAAzB,CAAlB;AACD,GA9FD;;AAgGArH,EAAAA,IAAI,CAACa,SAAL,GAAiB,SAASoH,aAAT,CAAuBC,MAAvB,EAA+B5C,MAA/B,EAAuC6C,mBAAvC,EAA4D;AAC3E;AACA,QAAI7E,KAAK,CAACC,OAAN,CAAc2E,MAAd,KAAyB,OAAO5C,MAAP,KAAkB,QAA/C,EAAyD;AACvD,WAAK,IAAI8C,CAAC,GAAGF,MAAM,CAACX,MAAP,GAAgB,CAA7B,EAAgCa,CAAC,IAAI,CAArC,EAAwCA,CAAC,EAAzC,EAA6C;AAC3CpI,QAAAA,IAAI,CAACa,SAAL,CAAeqH,MAAM,CAACE,CAAD,CAArB,EAA0B9C,MAA1B,EAAkC,IAAlC;AACD;;AACD,aAAOtF,IAAI,CAACY,SAAL,CAAesH,MAAM,CAAC,CAAD,CAArB,CAAP;AACD,KAP0E,CAS3E;;;AACA,QAAIG,YAAY,GAAGH,MAAnB;AACA,QAAI1B,YAAY,GAAGlB,MAAnB,CAX2E,CAa3E;;AACA,QAAIA,MAAM,KAAKgD,SAAX,IAAwB,OAAOJ,MAAP,KAAkB,QAA9C,EAAwD;AACtDG,MAAAA,YAAY,GAAG,IAAf;AACA7B,MAAAA,YAAY,GAAG0B,MAAf;AACD,KAjB0E,CAmB3E;;;AACA,QAAI,CAAC7H,OAAO,CAACmG,YAAD,CAAZ,EAA4B;AAC1BA,MAAAA,YAAY,GAAG+B,WAAW,CAAC/B,YAAD,EAAexE,SAAf,CAAX,IAAwCwE,YAAvD;AACD,KAtB0E,CAwB3E;;;AACA6B,IAAAA,YAAY,CAAC/C,MAAb,GAAsBjF,OAAO,CAACmG,YAAD,CAAP,GAAwBA,YAAxB,GAAuC7E,aAA7D,CAzB2E,CA2B3E;;AACA,QAAI,OAAOc,QAAP,KAAoB,QAAxB,EAAkC;AAChC,UAAIa,KAAK,CAACC,OAAN,CAAcd,QAAd,KAA2B,CAAC0F,mBAAhC,EAAqD;AACnD1F,QAAAA,QAAQ,CAACe,OAAT,CAAiB,UAAUC,CAAV,EAAa;AAC5BA,UAAAA,CAAC,CAAC6B,MAAF,GAAW+C,YAAY,CAAC/C,MAAxB;AACD,SAFD;AAGD,OAJD,MAIO;AACL7C,QAAAA,QAAQ,CAAC6C,MAAT,GAAkB+C,YAAY,CAAC/C,MAA/B;AACD;AACF,KApC0E,CAsC3E;;;AACA,QAAI+C,YAAY,CAACG,GAAb,IAAoB,CAACL,mBAAzB,EAA8C;AAC5C;AACA;AACA;AACA,UAAIE,YAAY,CAACG,GAAb,CAAiBC,MAArB,EAA6B;AAC3BzI,QAAAA,IAAI,CAACa,SAAL,CAAewH,YAAY,CAACG,GAA5B,EAAiCH,YAAY,CAAC/C,MAA9C,EAAsD,IAAtD;AACAtF,QAAAA,IAAI,CAACa,SAAL,CAAewH,YAAY,CAACG,GAAb,CAAiBC,MAAhC,EAAwCJ,YAAY,CAAC/C,MAArD,EAA6D,IAA7D;AACD,OAHD,MAGO;AACLtF,QAAAA,IAAI,CAACa,SAAL,CAAewH,YAAY,CAACG,GAA5B,EAAiCH,YAAY,CAAC/C,MAA9C;AACD;AACF,KAjD0E,CAmD3E;;;AACA,QAAI+C,YAAY,CAACI,MAAb,IAAuB,CAACN,mBAA5B,EAAiD;AAC/C;AACA;AACA;AACA,UAAIE,YAAY,CAACI,MAAb,CAAoBD,GAAxB,EAA6B;AAC3BxI,QAAAA,IAAI,CAACa,SAAL,CAAewH,YAAY,CAACI,MAA5B,EAAoCJ,YAAY,CAAC/C,MAAjD,EAAyD,IAAzD;AACAtF,QAAAA,IAAI,CAACa,SAAL,CAAewH,YAAY,CAACI,MAAb,CAAoBD,GAAnC,EAAwCH,YAAY,CAAC/C,MAArD,EAA6D,IAA7D;AACD,OAHD,MAGO;AACLtF,QAAAA,IAAI,CAACa,SAAL,CAAewH,YAAY,CAACI,MAA5B,EAAoCJ,YAAY,CAAC/C,MAAjD;AACD;AACF;;AAED,WAAOtF,IAAI,CAACY,SAAL,CAAeyH,YAAf,CAAP;AACD,GAjED;;AAmEArI,EAAAA,IAAI,CAACY,SAAL,GAAiB,SAAS8H,aAAT,CAAuBxD,OAAvB,EAAgC;AAC/C;AACA,QAAIA,OAAO,IAAIA,OAAO,CAACI,MAAvB,EAA+B;AAC7B,aAAOJ,OAAO,CAACI,MAAf;AACD,KAJ8C,CAM/C;;;AACA,WAAO,KAAKA,MAAL,IAAe3D,aAAtB;AACD,GARD;;AAUA3B,EAAAA,IAAI,CAACc,UAAL,GAAkB,SAAS6H,cAAT,CAAwBT,MAAxB,EAAgC5C,MAAhC,EAAwC;AACxD,QAAIkB,YAAJ,CADwD,CAGxD;;AACA,QACE,OAAO0B,MAAP,KAAkB,QAAlB,IACA,OAAOA,MAAM,CAAC5C,MAAd,KAAyB,QADzB,IAEAA,MAAM,KAAKgD,SAHb,EAIE;AACA9B,MAAAA,YAAY,GAAG0B,MAAM,CAAC5C,MAAtB;AACD,KAVuD,CAYxD;;;AACA,QACE,CAACkB,YAAD,IACA,OAAO0B,MAAP,KAAkB,QADlB,IAEA,OAAO5C,MAAP,KAAkB,QAHpB,EAIE;AACAkB,MAAAA,YAAY,GAAGlB,MAAf;AACD,KAnBuD,CAqBxD;;;AACA,QAAI,CAACkB,YAAD,IAAiBlB,MAAM,KAAKgD,SAA5B,IAAyC,OAAOJ,MAAP,KAAkB,QAA/D,EAAyE;AACvE1B,MAAAA,YAAY,GAAG0B,MAAf;AACD,KAxBuD,CA0BxD;;;AACA,QACE,CAAC1B,YAAD,IACA0B,MAAM,KAAKI,SADX,IAEAhD,MAAM,KAAKgD,SAFX,IAGA,OAAO,KAAKhD,MAAZ,KAAuB,QAJzB,EAKE;AACA,UAAI7C,QAAQ,IAAIA,QAAQ,CAACmG,MAAzB,EAAiC;AAC/BpC,QAAAA,YAAY,GAAG,EAAf;AACD,OAFD,MAEO;AACLA,QAAAA,YAAY,GAAG,KAAKlB,MAApB;AACD;AACF,KAtCuD,CAwCxD;;;AACA,QAAIkB,YAAY,KAAK8B,SAAjB,IAA8B9B,YAAY,KAAK,EAAnD,EAAuD;AACrD,aAAOnG,OAAP;AACD;;AAED,QAAI,CAACA,OAAO,CAACmG,YAAD,CAAZ,EAA4B;AAC1BA,MAAAA,YAAY,GAAG+B,WAAW,CAAC/B,YAAD,EAAexE,SAAf,CAAX,IAAwCwE,YAAvD;AACD;;AAED,QAAInG,OAAO,CAACmG,YAAD,CAAX,EAA2B;AACzB,aAAOnG,OAAO,CAACmG,YAAD,CAAd;AACD,KAFD,MAEO;AACLqC,MAAAA,OAAO,CAAC,2BAA2BrC,YAA3B,GAA0C,GAA3C,CAAP;AACA,aAAO,KAAP;AACD;AACF,GAvDD;;AAyDAxG,EAAAA,IAAI,CAACe,UAAL,GAAkB,SAAS+H,cAAT,GAA0B;AAC1C,WAAO7F,MAAM,CAACiB,IAAP,CAAY7D,OAAZ,CAAP;AACD,GAFD;;AAIAL,EAAAA,IAAI,CAACgB,SAAL,GAAiB,SAAS+H,aAAT,CAAuBzD,MAAvB,EAA+B;AAC9Cd,IAAAA,IAAI,CAACc,MAAD,CAAJ;AACD,GAFD;;AAIAtF,EAAAA,IAAI,CAACiB,YAAL,GAAoB,SAAS+H,gBAAT,CAA0B1D,MAA1B,EAAkC;AACpD,WAAOjF,OAAO,CAACiF,MAAD,CAAd;AACD,GAFD,CAnkBwC,CAukBxC;AACA;AACA;;;AAEA,MAAIc,WAAW,GAAG,UAAUV,GAAV,EAAeI,WAAf,EAA4BC,IAA5B,EAAkCsB,KAAlC,EAAyC;AACzD;AACA,QAAI,KAAK4B,IAAL,CAAUvD,GAAV,CAAJ,EAAoB;AAClBA,MAAAA,GAAG,GAAGwD,mBAAmB,CAACxD,GAAD,EAAM2B,KAAN,CAAzB;AACD,KAJwD,CAMzD;;;AACA,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B3B,MAAAA,GAAG,GAAG5G,QAAQ,CAAC4G,GAAD,EAAM,CAACgC,MAAM,CAACL,KAAD,CAAP,CAAN,CAAd;AACD,KATwD,CAWzD;;;AACA,QAAI,CAACnG,cAAc,CAACE,OAAhB,IAA2BC,aAAa,CAAC4H,IAAd,CAAmBvD,GAAnB,CAA/B,EAAwD;AACtDA,MAAAA,GAAG,GAAGlG,QAAQ,CAAC2J,MAAT,CAAgBzD,GAAhB,EAAqBI,WAArB,EAAkC,EAAlC,EAAsC5E,cAAc,CAACC,IAArD,CAAN;AACD,KAdwD,CAgBzD;AACA;;;AACA,QAAI,IAAI8H,IAAJ,CAASvD,GAAT,KAAiBK,IAAjB,IAAyBA,IAAI,CAACwB,MAAL,GAAc,CAA3C,EAA8C;AAC5C7B,MAAAA,GAAG,GAAG5G,QAAQ,CAAC4G,GAAD,EAAMK,IAAN,CAAd;AACD;;AAED,WAAOL,GAAP;AACD,GAvBD;;AAyBA,MAAI4B,sBAAsB,GAAG,UAAUvB,IAAV,EAAgB;AAC3C,WACEA,IAAI,CAACwB,MAAL,GAAc,CAAd,IACAxB,IAAI,CAACA,IAAI,CAACwB,MAAL,GAAc,CAAf,CAAJ,KAA0B,IAD1B,IAEA,OAAOxB,IAAI,CAACA,IAAI,CAACwB,MAAL,GAAc,CAAf,CAAX,KAAiC,QAHnC;AAKD,GAND;;AAQA,MAAI3B,SAAS,GAAG,UAAUG,IAAV,EAAgB;AAC9B,QAAID,WAAJ,EAAiBsD,UAAjB;;AAEA,QAAI9B,sBAAsB,CAACvB,IAAD,CAA1B,EAAkC;AAChCD,MAAAA,WAAW,GAAGC,IAAI,CAACA,IAAI,CAACwB,MAAL,GAAc,CAAf,CAAlB;AACA6B,MAAAA,UAAU,GAAG9F,KAAK,CAACJ,SAAN,CAAgBsE,KAAhB,CAAsBpE,IAAtB,CAA2B2C,IAA3B,EAAiC,CAAjC,EAAoC,CAAC,CAArC,CAAb;AACD,KAHD,MAGO;AACLD,MAAAA,WAAW,GAAG,EAAd;AACAsD,MAAAA,UAAU,GAAGrD,IAAI,CAACwB,MAAL,IAAe,CAAf,GAAmBjE,KAAK,CAACJ,SAAN,CAAgBsE,KAAhB,CAAsBpE,IAAtB,CAA2B2C,IAA3B,EAAiC,CAAjC,CAAnB,GAAyD,EAAtE;AACD;;AAED,WAAO,CAACD,WAAD,EAAcsD,UAAd,CAAP;AACD,GAZD;AAcA;AACF;AACA;;;AACE,MAAI1F,gBAAgB,GAAG,UAAUwE,MAAV,EAAkB;AACvC,QAAImB,aAAa,GAAG,IAApB,CADuC,CAGvC;;AACA,SAAK,IAAIrG,MAAT,IAAmB1C,GAAnB,EAAwB;AACtB,UAAI2C,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqC9C,GAArC,EAA0C0C,MAA1C,CAAJ,EAAuD;AACrD,YAAIK,KAAK,GAAG/C,GAAG,CAAC0C,MAAD,CAAf,CADqD,CAGrD;;AACA,YAAI,CAACkF,MAAM,CAAC7E,KAAD,CAAX,EAAoB;AAClBgG,UAAAA,aAAa,GAAG,KAAhB;AACAnB,UAAAA,MAAM,CAAC7E,KAAD,CAAN,GAAgBrD,IAAI,CAACgD,MAAD,CAAJ,CAAasG,IAAb,CAAkBpB,MAAlB,CAAhB;AACD;AACF;AACF,KAdsC,CAgBvC;;;AACA,QAAI,CAACA,MAAM,CAAC5C,MAAZ,EAAoB;AAClB4C,MAAAA,MAAM,CAAC5C,MAAP,GAAgB3D,aAAhB;AACD,KAnBsC,CAqBvC;;;AACA,QAAI0H,aAAJ,EAAmB;AACjB;AACD,KAxBsC,CA0BvC;;;AACA,QAAInB,MAAM,CAACM,GAAX,EAAgB;AACd9E,MAAAA,gBAAgB,CAACwE,MAAM,CAACM,GAAR,CAAhB;AACD,KA7BsC,CA+BvC;;;AACA,QAAIN,MAAM,CAACO,MAAX,EAAmB;AACjB/E,MAAAA,gBAAgB,CAACwE,MAAM,CAACO,MAAR,CAAhB;AACD;AACF,GAnCD;AAqCA;AACF;AACA;;;AACE,MAAItE,YAAY,GAAG,UAAUtC,SAAV,EAAqB;AACtC,QAAI0H,OAAO,GAAGrK,EAAE,CAACsK,WAAH,CAAe3H,SAAf,CAAd;AACA,QAAI4H,YAAY,GAAG,EAAnB;;AAEA,SAAK,IAAIrB,CAAC,GAAGmB,OAAO,CAAChC,MAAR,GAAiB,CAA9B,EAAiCa,CAAC,IAAI,CAAtC,EAAyCA,CAAC,EAA1C,EAA8C;AAC5C,UAAImB,OAAO,CAACnB,CAAD,CAAP,CAAWsB,KAAX,CAAiB,KAAjB,CAAJ,EAA6B;AAC7B,UAAI9E,cAAc,GAAGC,mBAAmB,CAAC0E,OAAO,CAACnB,CAAD,CAAR,CAAxC;AACA,UAAIxD,cAAJ,EAAoB6E,YAAY,CAAC1C,IAAb,CAAkBnC,cAAlB;AACrB;;AAED,WAAO6E,YAAY,CAAC3C,IAAb,EAAP;AACD,GAXD;AAaA;AACF;AACA;;;AACE,MAAIjC,mBAAmB,GAAG,UAAUF,QAAV,EAAoB;AAC5C,QAAIgF,cAAc,GAAG,IAAIrF,MAAJ,CAAWvC,SAAS,GAAG,GAAvB,EAA4B,GAA5B,CAArB;AACA,QAAI6H,WAAW,GAAG,IAAItF,MAAJ,CAAW,MAAM/B,MAAjB,EAAyB,GAAzB,CAAlB;AAEA,QAAI,CAACoC,QAAL,EAAe,OAAO,KAAP;AACf,QAAIpC,MAAM,IAAI,CAACoC,QAAQ,CAAC+E,KAAT,CAAeE,WAAf,CAAf,EAA4C,OAAO,KAAP;AAC5C,QAAI7H,SAAS,IAAI,CAAC4C,QAAQ,CAAC+E,KAAT,CAAeC,cAAf,CAAlB,EAAkD,OAAO,KAAP;AAClD,WAAOhF,QAAQ,CAAC5E,OAAT,CAAiBwC,MAAjB,EAAyB,EAAzB,EAA6BxC,OAA7B,CAAqC4J,cAArC,EAAqD,EAArD,CAAP;AACD,GARD;AAUA;AACF;AACA;AACA;;;AACE,MAAIE,oBAAoB,GAAG,UAAUC,aAAV,EAAyB;AAClD,QAAIxG,KAAK,CAACC,OAAN,CAAcuG,aAAd,CAAJ,EAAkC;AAChC,aAAOA,aAAa,CAACC,IAAd,CAAoBC,IAAD,IAAUA,IAAI,KAAK,EAAT,IAAeA,IAA5C,CAAP;AACD;;AACD,WAAO,OAAOF,aAAP,KAAyB,QAAzB,IAAqCA,aAA5C;AACD,GALD;AAOA;AACF;AACA;;;AAEE,MAAIzE,aAAa,GAAG,UAAUH,OAAV,EAAmB;AACrC,QAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAI+E,cAAc,GAAG/E,OAAO,CAACgF,OAAR,GACjBhF,OAAO,CAACgF,OAAR,CAAgBxI,kBAAhB,CADiB,GAEjB4G,SAFJ;AAGA,UAAI6B,SAAS,GAAG,EAAhB;AACA,UAAIC,OAAO,GAAG,EAAd;AAEAlF,MAAAA,OAAO,CAACiF,SAAR,GAAoB,CAACxI,aAAD,CAApB;AACAuD,MAAAA,OAAO,CAACkF,OAAR,GAAkB,CAACzI,aAAD,CAAlB;AACAuD,MAAAA,OAAO,CAACmF,QAAR,GAAmB1I,aAAnB;AACAuD,MAAAA,OAAO,CAACoF,MAAR,GAAiB3I,aAAjB,CAV+B,CAY/B;;AACA,UAAIa,cAAc,IAAI0C,OAAO,CAAC/F,GAA9B,EAAmC;AACjC,YAAIoL,WAAW,GACb,OAAOrF,OAAO,CAAC/F,GAAf,KAAuB,QAAvB,GAAkC+F,OAAO,CAAC/F,GAA1C,GAAgD+F,OAAO,CAAC/F,GAAR,CAAYqL,QAAZ,EADlD;AAGA;AACR;AACA;AACA;AACQ;;AACA,YAAIC,MAAM,GAAGtL,GAAG,CAACuL,KAAJ,CAAUH,WAAV,EAAuB,IAAvB,CAAb;AACA,YAAII,sBAAsB,GAAGF,MAAM,CAACG,KAAP,CAAapI,cAAb,CAA7B;;AACA,YAAImI,sBAAJ,EAA4B;AAC1B,cAAIb,aAAa,GAAGD,oBAAoB,CAACc,sBAAD,CAAxC;;AACA,cAAIb,aAAJ,EAAmB;AACjB/E,YAAAA,QAAQ,CAAC,mCAAmC+E,aAApC,CAAR;;AACA,gBAAIzH,kBAAJ,EAAwB;AACtByH,cAAAA,aAAa,GAAGA,aAAa,CAACjC,WAAd,EAAhB;AACD;;AACD,mBAAO7H,IAAI,CAACa,SAAL,CAAeqE,OAAf,EAAwB4E,aAAxB,CAAP;AACD;AACF;AACF,OAlC8B,CAoC/B;;;AACA,UAAIrI,UAAU,IAAIyD,OAAO,CAAC2F,OAAtB,IAAiC3F,OAAO,CAAC2F,OAAR,CAAgBpJ,UAAhB,CAArC,EAAkE;AAChEyD,QAAAA,OAAO,CAACmF,QAAR,GAAmBnF,OAAO,CAAC2F,OAAR,CAAgBpJ,UAAhB,CAAnB;AACA,eAAOzB,IAAI,CAACa,SAAL,CAAeqE,OAAf,EAAwBA,OAAO,CAACmF,QAAhC,CAAP;AACD,OAxC8B,CA0C/B;;;AACA,UAAIJ,cAAJ,EAAoB;AAClB,YAAIa,iBAAiB,GAAGC,8BAA8B,CAACd,cAAD,CAAtD;AACA,YAAIP,KAAJ;AACA,YAAIsB,aAAJ;AACA,YAAIC,QAAJ;;AACA,aAAK,IAAI7C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0C,iBAAiB,CAACvD,MAAtC,EAA8Ca,CAAC,EAA/C,EAAmD;AACjD,cAAI4B,IAAI,GAAGc,iBAAiB,CAAC1C,CAAD,CAA5B;AACA,cAAI8C,EAAE,GAAGlB,IAAI,CAAClC,KAAL,CAAW,GAAX,EAAgB,CAAhB,CAAT;AACA,cAAIqD,UAAU,GAAGD,EAAE,CAAC,CAAD,CAAnB;AACA,cAAIZ,MAAM,GAAGY,EAAE,CAAC,CAAD,CAAf,CAJiD,CAMjD;;AACA,cAAIE,YAAY,GAAG7C,WAAW,CAACyB,IAAD,EAAOhI,SAAP,CAA9B;;AACA,cAAIoJ,YAAJ,EAAkB;AAChBH,YAAAA,QAAQ,GAAGG,YAAX,CADgB,CAEhB;AACA;;AACA,gBAAIC,qBAAqB,GAAGP,iBAAiB,CAAChG,OAAlB,CAA0BkF,IAA1B,CAA5B;AACA,gBAAIsB,aAAa,GAAGR,iBAAiB,CAAChG,OAAlB,CAA0BmG,QAA1B,CAApB;;AACA,gBAAIK,aAAa,GAAG,CAAC,CAArB,EAAwB;AACtBR,cAAAA,iBAAiB,CAACS,MAAlB,CAAyBD,aAAzB,EAAwC,CAAxC;AACD;;AACDR,YAAAA,iBAAiB,CAACS,MAAlB,CAAyBF,qBAAqB,GAAG,CAAjD,EAAoD,CAApD,EAAuDJ,QAAvD;AACD,WAlBgD,CAoBjD;;;AACA,cAAIO,kBAAkB,GAAGjD,WAAW,CAAC4C,UAAD,EAAanJ,SAAb,CAApC;;AACA,cAAIwJ,kBAAJ,EAAwB;AACtBP,YAAAA,QAAQ,GAAGO,kBAAX,CADsB,CAEtB;AACA;AACA;;AACA,gBAAIV,iBAAiB,CAAChG,OAAlB,CAA0BmG,QAA1B,IAAsC,CAA1C,EAA6C;AAC3CH,cAAAA,iBAAiB,CAAC/D,IAAlB,CAAuBkE,QAAvB;AACD;AACF;;AAED,cAAId,SAAS,CAACrF,OAAV,CAAkBqG,UAAlB,IAAgC,CAApC,EAAuC;AACrChB,YAAAA,SAAS,CAACpD,IAAV,CAAeoE,UAAU,CAACtD,WAAX,EAAf;AACD;;AACD,cAAIyC,MAAJ,EAAY;AACVF,YAAAA,OAAO,CAACrD,IAAR,CAAauD,MAAM,CAACzC,WAAP,EAAb;AACD;;AAED,cAAI,CAAC6B,KAAD,IAAUrJ,OAAO,CAAC2J,IAAD,CAArB,EAA6B;AAC3BN,YAAAA,KAAK,GAAGM,IAAR;AACA;AACD;;AAED,cAAI,CAACgB,aAAD,IAAkB3K,OAAO,CAAC8K,UAAD,CAA7B,EAA2C;AACzCH,YAAAA,aAAa,GAAGG,UAAhB;AACD;AACF;;AAEDjG,QAAAA,OAAO,CAACmF,QAAR,GAAmBX,KAAK,IAAIsB,aAAT,IAA0B9F,OAAO,CAACmF,QAArD;AACAnF,QAAAA,OAAO,CAACoF,MAAR,GAAiBF,OAAO,CAAC,CAAD,CAAP,IAAclF,OAAO,CAACoF,MAAvC;AACA,eAAOtK,IAAI,CAACa,SAAL,CAAeqE,OAAf,EAAwBA,OAAO,CAACmF,QAAhC,CAAP;AACD;AACF,KAtGoC,CAwGrC;;;AACA,WAAOrK,IAAI,CAACa,SAAL,CAAeqE,OAAf,EAAwBvD,aAAxB,CAAP;AACD,GA1GD;AA4GA;AACF;AACA;;;AACE,MAAIoJ,8BAA8B,GAAG,UAAUnH,MAAV,EAAkB;AACrD,QAAIuG,SAAS,GAAGvG,MAAM,CAACkE,KAAP,CAAa,GAAb,CAAhB;AACA,QAAI2D,WAAW,GAAG,EAAlB;AACA,WAAOtB,SAAS,CACbuB,GADI,CACA,SAASC,uBAAT,CAAiCC,IAAjC,EAAuC;AAC1C,UAAIC,eAAe,GAAGD,IAAI,CAACE,IAAL,GAAYhE,KAAZ,CAAkB,KAAlB,CAAtB;;AACA,UAAI+D,eAAe,CAACtE,MAAhB,GAAyB,CAA7B,EAAgC;AAC9BsE,QAAAA,eAAe,CAAC,CAAD,CAAf,GAAqB,GAArB;AACD,OAFD,MAEO;AACL,YAAIE,OAAO,GAAGC,UAAU,CAACH,eAAe,CAAC,CAAD,CAAhB,CAAxB;AACAA,QAAAA,eAAe,CAAC,CAAD,CAAf,GAAqBE,OAAO,IAAI,GAAhC;AACD;;AACDN,MAAAA,WAAW,CAACI,eAAe,CAAC,CAAD,CAAhB,CAAX,GAAkCA,eAAe,CAAC,CAAD,CAAjD;AAEA,aAAOA,eAAe,CAAC,CAAD,CAAtB;AACD,KAZI,EAaJ9D,MAbI,CAaG,UAAUiC,IAAV,EAAgB;AACtB,aAAOyB,WAAW,CAACzB,IAAD,CAAX,GAAoB,CAA3B;AACD,KAfI,EAgBJlD,IAhBI,CAgBC,SAASmF,aAAT,CAAuBC,CAAvB,EAA0BC,CAA1B,EAA6B;AACjC,aAAOV,WAAW,CAACU,CAAD,CAAX,GAAiBV,WAAW,CAACS,CAAD,CAAnC;AACD,KAlBI,CAAP;AAmBD,GAtBD;AAwBA;AACF;AACA;;;AAEE,MAAIjG,mBAAmB,GAAG,UAAUmG,GAAV,EAAe;AACvC,QAAI9G,MAAJ;;AACA,QAAI8G,GAAG,IAAIA,GAAG,CAACC,KAAf,EAAsB;AACpB/G,MAAAA,MAAM,GAAG8G,GAAG,CAACC,KAAJ,CAAU/G,MAAnB;AACD;;AACD,QAAI8G,GAAG,IAAIA,GAAG,CAAC9G,MAAf,EAAuB;AACrBA,MAAAA,MAAM,GAAG8G,GAAG,CAAC9G,MAAb;AACD;;AACD,WAAOA,MAAP;AACD,GATD;AAWA;AACF;AACA;;;AACE,MAAI4D,mBAAmB,GAAG,UAAUzD,MAAV,EAAkB4B,KAAlB,EAAyB;AACjD,QAAIiF,YAAY,GAAG7G,MAAnB;AACA,QAAI8G,OAAO,GAAG9G,MAAM,CAACqC,KAAP,CAAa,IAAb,CAAd;AACA,QAAI0E,kBAAkB,GAAG,KAAzB,CAHiD,CAKjD;;AACAD,IAAAA,OAAO,CAACE,IAAR,CAAa,UAAU9E,CAAV,EAAa;AACxB,UAAI+E,OAAO,GAAG/E,CAAC,CAAC+B,KAAF,CAAQ,uCAAR,CAAd,CADwB,CAGxB;;AACA,UAAIgD,OAAO,IAAI,IAAX,IAAmBA,OAAO,CAAC,CAAD,CAA9B,EAAmC;AACjCF,QAAAA,kBAAkB,GAAG,IAArB;;AACA,YAAIG,aAAa,CAACtF,KAAD,EAAQqF,OAAO,CAAC,CAAD,CAAf,CAAb,KAAqC,IAAzC,EAA+C;AAC7CJ,UAAAA,YAAY,GAAGI,OAAO,CAAC,CAAD,CAAtB;AACA,iBAAO,IAAP;AACD;AACF,OAND,MAMO;AACL;AACA,YAAIF,kBAAJ,EAAwB;AACtBF,UAAAA,YAAY,GAAG3E,CAAf;AACD;AACF;AACF,KAhBD;AAiBA,WAAO2E,YAAP;AACD,GAxBD;AA0BA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,MAAIK,aAAa,GAAG,UAAUC,MAAV,EAAkBC,QAAlB,EAA4B;AAC9CA,IAAAA,QAAQ,GAAGlN,aAAa,CAACkN,QAAD,CAAxB;;AACA,QAAIA,QAAQ,IAAI,OAAOD,MAAP,KAAkB,QAAlC,EAA4C;AAC1C,UAAIC,QAAQ,CAACC,IAAT,CAAcC,KAAd,KAAwBH,MAA5B,EAAoC;AAClC,eAAOC,QAAQ,CAACC,IAAT,CAAcE,QAArB;AACD;;AACD,UAAIH,QAAQ,CAACI,EAAT,CAAYF,KAAZ,KAAsBH,MAA1B,EAAkC;AAChC,eAAOC,QAAQ,CAACI,EAAT,CAAYD,QAAnB;AACD;;AAED,aACEE,IAAI,CAACC,GAAL,CAASN,QAAQ,CAACC,IAAT,CAAcC,KAAvB,EAA8BH,MAA9B,MAA0CC,QAAQ,CAACC,IAAT,CAAcC,KAAxD,IACAG,IAAI,CAACE,GAAL,CAASP,QAAQ,CAACI,EAAT,CAAYF,KAArB,EAA4BH,MAA5B,MAAwCC,QAAQ,CAACI,EAAT,CAAYF,KAFtD;AAID;;AACD,WAAO,KAAP;AACD,GAhBD;AAkBA;AACF;AACA;;;AACE,MAAI/G,SAAS,GAAG,UAAUV,MAAV,EAAkB6B,QAAlB,EAA4BC,MAA5B,EAAoCiG,kBAApC,EAAwD;AACtE;AACA,QAAI,CAACA,kBAAD,IAAuB1K,SAA3B,EAAsC;AACpC2K,MAAAA,cAAc,CAACnG,QAAD,EAAWC,MAAX,CAAd;AACD;;AAED,QAAI9B,MAAM,KAAKgD,SAAf,EAA0B;AACxBO,MAAAA,OAAO,CACL,0EACElH,aADF,GAEE,oBAHG,CAAP;AAKA2D,MAAAA,MAAM,GAAG3D,aAAT;AACD,KAbqE,CAetE;;;AACA,QAAI,CAACtB,OAAO,CAACiF,MAAD,CAAZ,EAAsB;AACpBA,MAAAA,MAAM,GAAGiD,WAAW,CAACjD,MAAD,EAAStD,SAAT,CAAX,IAAkCsD,MAA3C;AACD,KAlBqE,CAoBtE;;;AACA,QAAI,CAACjF,OAAO,CAACiF,MAAD,CAAZ,EAAsB;AACpBd,MAAAA,IAAI,CAACc,MAAD,CAAJ;AACD,KAvBqE,CAyBtE;;;AACA,QAAI,CAACjF,OAAO,CAACiF,MAAD,CAAZ,EAAsB;AACpBuD,MAAAA,OAAO,CACL,kBACEvD,MADF,GAEE,kEAFF,GAGE3D,aAHF,GAIE,8BALG,CAAP;AAQA2D,MAAAA,MAAM,GAAG3D,aAAT;AACA6C,MAAAA,IAAI,CAACc,MAAD,CAAJ;AACD,KArCqE,CAuCtE;;;AACA,QAAIiI,eAAe,GAAGpG,QAAtB;AACA,QAAIqG,aAAa,GAAGpG,MAApB;;AACA,QAAI9E,cAAJ,EAAoB;AAClB,UAAImL,YAAY,GAAGtG,QAAQ,CAACrC,OAAT,CAAiB,GAAjB,CAAnB,CADkB,CAElB;AACA;;AACA,UAAI2I,YAAY,GAAG,CAAnB,EAAsB;AACpBF,QAAAA,eAAe,GAAGpG,QAAQ,CAACuG,SAAT,CAAmBD,YAAY,GAAG,CAAlC,CAAlB;AACAtG,QAAAA,QAAQ,GAAGA,QAAQ,CAACuG,SAAT,CAAmB,CAAnB,EAAsBD,YAAtB,CAAX;AACD;;AACD,UAAIrG,MAAM,IAAI,OAAOA,MAAP,KAAkB,QAAhC,EAA0C;AACxCqG,QAAAA,YAAY,GAAGrG,MAAM,CAACtC,OAAP,CAAe,GAAf,CAAf;;AACA,YAAI2I,YAAY,GAAG,CAAnB,EAAsB;AACpBD,UAAAA,aAAa,GAAGpG,MAAM,CAACsG,SAAP,CAAiBD,YAAY,GAAG,CAAhC,CAAhB;AACArG,UAAAA,MAAM,GAAGA,MAAM,CAACsG,SAAP,CAAiB,CAAjB,EAAoBD,YAApB,CAAT;AACD;AACF;AACF;;AAED,QAAIE,QAAQ,GAAGC,cAAc,CAACtI,MAAD,EAAS6B,QAAT,CAA7B;AACA,QAAI0G,OAAO,GAAGC,aAAa,CAACxI,MAAD,EAAS6B,QAAT,CAA3B,CA5DsE,CA8DtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA,QAAIC,MAAJ,EAAY;AACV,UAAIuG,QAAQ,MAAM,IAAlB,EAAwB;AACtB;AACA,YAAI/L,oBAAoB,IAAI0D,MAAM,KAAK3D,aAAvC,EAAsD;AACpDoD,UAAAA,QAAQ,CACN,aACEoC,QADF,GAEE,MAFF,GAGE7B,MAHF,GAIE,eAJF,GAKE3D,aANI,CAAR;AAQAkM,UAAAA,OAAO,CAAC7H,SAAS,CAACrE,aAAD,EAAgBwF,QAAhB,EAA0BC,MAA1B,CAAV,CAAP;AACD,SAVD,MAUO;AACLyG,UAAAA,OAAO,CAAC;AACN3H,YAAAA,GAAG,EAAEqH,eAAe,IAAIpG,QADlB;AAENhB,YAAAA,KAAK,EAAEqH,aAAa,IAAIpG;AAFlB,WAAD,CAAP;AAID;;AACD2G,QAAAA,KAAK,CAACzI,MAAD,CAAL;AACD;AACF;;AAED,QAAIqI,QAAQ,MAAM,IAAlB,EAAwB;AACtB;AACA,UAAI/L,oBAAoB,IAAI0D,MAAM,KAAK3D,aAAvC,EAAsD;AACpDoD,QAAAA,QAAQ,CACN,aACEoC,QADF,GAEE,MAFF,GAGE7B,MAHF,GAIE,eAJF,GAKE3D,aANI,CAAR;AAQAkM,QAAAA,OAAO,CAAC7H,SAAS,CAACrE,aAAD,EAAgBwF,QAAhB,EAA0BC,MAA1B,CAAV,CAAP;AACD,OAVD,MAUO;AACLyG,QAAAA,OAAO,CAACN,eAAe,IAAIpG,QAApB,CAAP;AACD;;AACD4G,MAAAA,KAAK,CAACzI,MAAD,CAAL;AACD;;AAED,WAAOqI,QAAQ,EAAf;AACD,GAvHD;AAyHA;AACF;AACA;AACA;;;AACE,MAAIL,cAAc,GAAG,UAAUnG,QAAV,EAAoBC,MAApB,EAA4B;AAC/C;AACA;AACA;AACA,SAAK,IAAI7C,CAAT,IAAclE,OAAd,EAAuB;AACrB2F,MAAAA,SAAS,CAACzB,CAAD,EAAI4C,QAAJ,EAAcC,MAAd,EAAsB,IAAtB,CAAT;AACD;AACF,GAPD;AASA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,MAAIwG,cAAc,GAAG,UAAUtI,MAAV,EAAkB6B,QAAlB,EAA4B6G,qBAA5B,EAAmD;AACtE;AACA,QAAI,CAAC3N,OAAO,CAACiF,MAAD,CAAZ,EAAsB,OAAO2I,QAAQ,CAAC/K,SAAhB,CAFgD,CAItE;;AACA,QAAIgL,UAAU,GAAG5L,cAAc,IAAI6E,QAAQ,CAACgH,WAAT,CAAqB7L,cAArB,CAAnC;;AACA,QAAIA,cAAc,IAAI4L,UAAU,GAAG,CAA/B,IAAoCA,UAAU,GAAG/G,QAAQ,CAACI,MAAT,GAAkB,CAAvE,EAA0E;AACxE;AACA,UAAI,OAAOyG,qBAAP,KAAiC,WAArC,EACEA,qBAAqB,GAAG,IAAxB,CAHsE,CAIxE;;AACA,UAAIL,QAAQ,GAAG,IAAf,CALwE,CAMxE;;AACA,UAAIS,YAAY,GAAG,YAAY;AAC7B,eAAO,IAAP;AACD,OAFD,CAPwE,CAUxE;;;AACA,UAAIC,UAAU,GAAG,KAAjB,CAXwE,CAYxE;;AACAlH,MAAAA,QAAQ,CAACW,KAAT,CAAexF,cAAf,EAA+BgM,MAA/B,CAAsC,UAAUpG,MAAV,EAAkBqG,KAAlB,EAAyB;AAC7D;AACAZ,QAAAA,QAAQ,GAAGS,YAAX,CAF6D,CAG7D;AACA;;AACA,YACElG,MAAM,KAAK,IAAX,IACA,CAACjF,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqC8E,MAArC,EAA6CqG,KAA7C,CAFH,EAGE;AACA;AACAF,UAAAA,UAAU,GAAGL,qBAAb,CAFA,CAGA;;AACA,iBAAO,IAAP;AACD,SAb4D,CAc7D;;;AACAL,QAAAA,QAAQ,GAAG,YAAY;AACrB,iBAAOzF,MAAM,CAACqG,KAAD,CAAb;AACD,SAFD,CAf6D,CAkB7D;;;AACA,eAAOrG,MAAM,CAACqG,KAAD,CAAb;AACD,OApBD,EAoBGlO,OAAO,CAACiF,MAAD,CApBV,EAbwE,CAkCxE;;AACA,aAAO,YAAY;AACjB;AACA;AACA;AACA,eAAO+I,UAAU,GACbT,cAAc,CAACtI,MAAD,EAAS6B,QAAT,EAAmB,KAAnB,CAAd,EADa,GAEbwG,QAAQ,EAFZ;AAGD,OAPD;AAQD,KA3CD,MA2CO;AACL;AACA,aAAO,YAAY;AACjB,eAAOtN,OAAO,CAACiF,MAAD,CAAP,CAAgB6B,QAAhB,CAAP;AACD,OAFD;AAGD;AACF,GAvDD;AAyDA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,MAAI2G,aAAa,GAAG,UAAUxI,MAAV,EAAkB6B,QAAlB,EAA4BqH,cAA5B,EAA4C;AAC9D;AACA,QAAI,CAACnO,OAAO,CAACiF,MAAD,CAAZ,EAAsB,OAAO2I,QAAQ,CAAC/K,SAAhB,CAFwC,CAI9D;;AACA,QAAIgL,UAAU,GAAG5L,cAAc,IAAI6E,QAAQ,CAACgH,WAAT,CAAqB7L,cAArB,CAAnC;;AACA,QAAIA,cAAc,IAAI4L,UAAU,GAAG,CAA/B,IAAoCA,UAAU,GAAG/G,QAAQ,CAACI,MAAT,GAAkB,CAAvE,EAA0E;AACxE;AACA,UAAI,OAAOiH,cAAP,KAA0B,WAA9B,EAA2CA,cAAc,GAAG,KAAjB,CAF6B,CAGxE;;AACA,UAAIb,QAAQ,GAAG,IAAf,CAJwE,CAKxE;;AACA,UAAIS,YAAY,GAAG,YAAY;AAC7B,eAAO,IAAP;AACD,OAFD,CANwE,CASxE;;;AACA,UAAIK,SAAS,GAAG,YAAY;AAC1B,eAAO,EAAP;AACD,OAFD,CAVwE,CAaxE;;;AACA,UAAIJ,UAAU,GAAG,KAAjB,CAdwE,CAexE;;AACAlH,MAAAA,QAAQ,CAACW,KAAT,CAAexF,cAAf,EAA+BgM,MAA/B,CAAsC,UAAUpG,MAAV,EAAkBqG,KAAlB,EAAyB;AAC7D;AACAZ,QAAAA,QAAQ,GAAGS,YAAX,CAF6D,CAG7D;AACA;;AACA,YACElG,MAAM,KAAK,IAAX,IACA,CAACjF,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqC8E,MAArC,EAA6CqG,KAA7C,CAFH,EAGE;AACA;AACA,cAAIC,cAAJ,EAAoB;AAClB;AACA,gBAAItG,MAAM,KAAK,IAAX,IAAmB,OAAOA,MAAP,KAAkB,QAAzC,EAAmD;AACjDA,cAAAA,MAAM,GAAGuG,SAAS,EAAlB;AACD,aAJiB,CAKlB;;;AACAvG,YAAAA,MAAM,CAACqG,KAAD,CAAN,GAAgB,EAAhB;AACD,WAPD,MAOO;AACL;AACAF,YAAAA,UAAU,GAAG,IAAb,CAFK,CAGL;;AACA,mBAAO,IAAP;AACD;AACF,SAvB4D,CAwB7D;;;AACAV,QAAAA,QAAQ,GAAG,UAAUZ,KAAV,EAAiB;AAC1B7E,UAAAA,MAAM,CAACqG,KAAD,CAAN,GAAgBxB,KAAhB;AACA,iBAAOA,KAAP;AACD,SAHD,CAzB6D,CA6B7D;;;AACA0B,QAAAA,SAAS,GAAG,YAAY;AACtBvG,UAAAA,MAAM,CAACqG,KAAD,CAAN,GAAgB,EAAhB;AACA,iBAAOrG,MAAM,CAACqG,KAAD,CAAb;AACD,SAHD,CA9B6D,CAmC7D;;;AACA,eAAOrG,MAAM,CAACqG,KAAD,CAAb;AACD,OArCD,EAqCGlO,OAAO,CAACiF,MAAD,CArCV,EAhBwE,CAuDxE;;AACA,aAAO,UAAUyH,KAAV,EAAiB;AACtB;AACA;AACA;AACA;AACAA,QAAAA,KAAK,GAAGnK,YAAY,CAAC0C,MAAD,EAASyH,KAAT,CAApB;AACA,eAAOsB,UAAU,GACbP,aAAa,CAACxI,MAAD,EAAS6B,QAAT,EAAmB,IAAnB,CAAb,CAAsC4F,KAAtC,CADa,GAEbY,QAAQ,CAACZ,KAAD,CAFZ;AAGD,OATD;AAUD,KAlED,MAkEO;AACL;AACA,aAAO,UAAUA,KAAV,EAAiB;AACtBA,QAAAA,KAAK,GAAGnK,YAAY,CAAC0C,MAAD,EAASyH,KAAT,CAApB;AACA1M,QAAAA,OAAO,CAACiF,MAAD,CAAP,CAAgB6B,QAAhB,IAA4B4F,KAA5B;AACA,eAAOA,KAAP;AACD,OAJD;AAKD;AACF,GAhFD;AAkFA;AACF;AACA;;;AACE,MAAIvI,IAAI,GAAG,UAAUc,MAAV,EAAkB;AAC3B,QAAIoJ,UAAU,GAAG,EAAjB;AACA,QAAIC,IAAI,GAAGC,kBAAkB,CAACtJ,MAAD,CAA7B;;AACA,QAAI;AACFP,MAAAA,QAAQ,CAAC,UAAU4J,IAAV,GAAiB,eAAjB,GAAmCrJ,MAApC,CAAR;AACAoJ,MAAAA,UAAU,GAAGxP,EAAE,CAAC2P,YAAH,CAAgBF,IAAhB,CAAb;;AACA,UAAI;AACF;AACAtO,QAAAA,OAAO,CAACiF,MAAD,CAAP,GAAkBwJ,IAAI,CAACpE,KAAL,CAAWgE,UAAX,CAAlB;AACD,OAHD,CAGE,OAAOK,UAAP,EAAmB;AACnBxJ,QAAAA,QAAQ,CACN,8CACEoJ,IADF,GAEE,+BAHI,EAINI,UAJM,CAAR;AAMD;AACF,KAdD,CAcE,OAAOC,SAAP,EAAkB;AAClB;AACA;AACA;AAEA;AACA,UAAI9P,EAAE,CAAC+P,UAAH,CAAcN,IAAd,CAAJ,EAAyB;AACvB5J,QAAAA,QAAQ,CACN,+BAA+BO,MAA/B,GAAwC,MAAxC,GAAiDqJ,IAAjD,GAAwD,UADlD,CAAR;AAGAzP,QAAAA,EAAE,CAACgQ,UAAH,CAAcP,IAAd,EAAoBA,IAAI,GAAG,UAA3B;AACD;;AAED5J,MAAAA,QAAQ,CAAC,kBAAkB4J,IAAnB,CAAR;AACAZ,MAAAA,KAAK,CAACzI,MAAD,CAAL;AACD;AACF,GAjCD;AAmCA;AACF;AACA;;;AACE,MAAIyI,KAAK,GAAG,UAAUzI,MAAV,EAAkB;AAC5B,QAAI6J,KAAJ,EAAWC,MAAX,EAAmBC,GAAnB,CAD4B,CAG5B;;AACA,QAAI,CAAC3M,WAAL,EAAkB;AAChB;AACD,KAN2B,CAQ5B;;;AACA,QAAI;AACFyM,MAAAA,KAAK,GAAGjQ,EAAE,CAACoQ,SAAH,CAAazN,SAAb,CAAR;AACD,KAFD,CAEE,OAAO0N,CAAP,EAAU;AACVxK,MAAAA,QAAQ,CAAC,8BAA8BlD,SAA/B,CAAR;;AACA,UAAI;AACF3C,QAAAA,EAAE,CAACsQ,SAAH,CAAa3N,SAAb,EAAwBC,oBAAxB;AACD,OAFD,CAEE,OAAOyN,CAAP,EAAU;AACV;AACA,YAAIA,CAAC,CAACE,IAAF,KAAW,QAAf,EAAyB,MAAMF,CAAN;AAC1B;AACF,KAnB2B,CAqB5B;;;AACA,QAAI,CAAClP,OAAO,CAACiF,MAAD,CAAZ,EAAsB;AACpBjF,MAAAA,OAAO,CAACiF,MAAD,CAAP,GAAkB,EAAlB;AACD,KAxB2B,CA0B5B;;;AACA,QAAI;AACF8J,MAAAA,MAAM,GAAGR,kBAAkB,CAACtJ,MAAD,CAA3B;AACA+J,MAAAA,GAAG,GAAGD,MAAM,GAAG,MAAf;AACAlQ,MAAAA,EAAE,CAACwQ,aAAH,CACEL,GADF,EAEEP,IAAI,CAACa,SAAL,CAAetP,OAAO,CAACiF,MAAD,CAAtB,EAAgC,IAAhC,EAAsCrD,MAAtC,CAFF,EAGE,MAHF;AAKAkN,MAAAA,KAAK,GAAGjQ,EAAE,CAAC0Q,QAAH,CAAYP,GAAZ,CAAR;;AACA,UAAIF,KAAK,CAACU,MAAN,EAAJ,EAAoB;AAClB3Q,QAAAA,EAAE,CAACgQ,UAAH,CAAcG,GAAd,EAAmBD,MAAnB;AACD,OAFD,MAEO;AACL7J,QAAAA,QAAQ,CACN,6CACE8J,GADF,GAEE,MAFF,GAGED,MAHF,GAIE,wBALI,CAAR;AAOD;AACF,KApBD,CAoBE,OAAOG,CAAP,EAAU;AACVhK,MAAAA,QAAQ,CACN,4CACE8J,GADF,GAEE,MAFF,GAGED,MAHF,GAIE,wBALI,EAMNG,CANM,CAAR;AAQD;AACF,GAzDD;AA2DA;AACF;AACA;;;AACE,MAAIX,kBAAkB,GAAG,UAAUtJ,MAAV,EAAkB;AACzC;AACA,QAAIwK,GAAG,GAAG/N,SAAS,IAAI,OAAvB;AACA,QAAIgO,QAAQ,GAAG3Q,IAAI,CAAC4Q,SAAL,CAAenO,SAAS,GAAGP,OAAZ,GAAsBiB,MAAtB,GAA+B+C,MAA/B,GAAwCwK,GAAvD,CAAf;AACA,QAAIG,UAAU,GAAG7Q,IAAI,CAAC4Q,SAAL,CACfnO,SAAS,GAAGP,OAAZ,GAAsBiB,MAAtB,GAA+B+C,MAA/B,GAAwC,KADzB,CAAjB,CAJyC,CAOzC;;AACA,QAAI;AACF,UAAIpG,EAAE,CAAC0Q,QAAH,CAAYK,UAAZ,CAAJ,EAA6B;AAC3BlL,QAAAA,QAAQ,CAAC,yBAAyBkL,UAA1B,CAAR;AACAlO,QAAAA,SAAS,GAAG,KAAZ;AACA,eAAOkO,UAAP;AACD;AACF,KAND,CAME,OAAOV,CAAP,EAAU;AACVxK,MAAAA,QAAQ,CAAC,cAAcgL,QAAf,CAAR;AACD;;AACD,WAAOA,QAAP;AACD,GAlBD;AAoBA;AACF;AACA;;;AACE,MAAIxH,WAAW,GAAG,UAAU/B,YAAV,EAAwBxE,SAAxB,EAAmC;AACnDA,IAAAA,SAAS,GAAGA,SAAS,IAAI,EAAzB;AACA,QAAIA,SAAS,CAACwE,YAAD,CAAb,EAA6B,OAAOxE,SAAS,CAACwE,YAAD,CAAhB;AAC7B,QAAI0J,cAAc,GAAG,IAArB;;AACA,SAAK,IAAIC,GAAT,IAAgBnO,SAAhB,EAA2B;AACzB,UAAIwE,YAAY,CAACkD,KAAb,CAAmB,IAAIpF,MAAJ,CAAW,MAAM6L,GAAG,CAACpQ,OAAJ,CAAY,GAAZ,EAAiB,IAAjB,CAAN,GAA+B,GAA1C,CAAnB,CAAJ,EAAwE;AACtEmQ,QAAAA,cAAc,GAAGlO,SAAS,CAACmO,GAAD,CAA1B;AACA;AACD;AACF;;AACD,WAAOD,cAAP;AACD,GAXD;AAaA;AACF;AACA;;;AACE,WAASnL,QAAT,CAAkBW,GAAlB,EAAuB;AACrBxD,IAAAA,UAAU,CAACwD,GAAD,CAAV;AACD;;AAED,WAASmD,OAAT,CAAiBnD,GAAjB,EAAsB;AACpBtD,IAAAA,SAAS,CAACsD,GAAD,CAAT;AACD;;AAED,WAASH,QAAT,CAAkBG,GAAlB,EAAuB;AACrBvD,IAAAA,UAAU,CAACuD,GAAD,CAAV;AACD;AAED;AACF;AACA;;;AACE,WAAS1B,UAAT,CAAoBsB,MAApB,EAA4ByH,KAA5B,EAAmC;AACjC,WAAOA,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACE,MAAI7M,KAAJ,EAAWF,IAAI,CAAC6C,SAAL,CAAe3C,KAAf;AAEX,SAAOF,IAAP;AACD,CAl3CD;;AAo3CAoQ,MAAM,CAACC,OAAP,GAAiBrQ,IAAjB","sourcesContent":["/**\n * @author      Created by Marcus Spiegel <spiegel@uscreen.de> on 2011-03-25.\n * @link        https://github.com/mashpie/i18n-node\n * @license     http://opensource.org/licenses/MIT\n */\n\n'use strict'\n\n// dependencies\nvar vsprintf = require('sprintf-js').vsprintf\nvar pkgVersion = require('./package.json').version\nvar fs = require('fs')\nvar url = require('url')\nvar path = require('path')\nvar debug = require('debug')('i18n:debug')\nvar warn = require('debug')('i18n:warn')\nvar error = require('debug')('i18n:error')\nvar Mustache = require('mustache')\nvar Messageformat = require('messageformat')\nvar MakePlural = require('make-plural')\nvar parseInterval = require('math-interval-parser').default\n\n// utils\nvar escapeRegExp = function (string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') // $& means the whole matched string\n}\n\n// create constructor function\nconst i18n = function I18n(_OPTS = false) {\n  var MessageformatInstanceForLocale = {}\n  var PluralsForLocale = {}\n  var locales = {}\n  var api = {\n    __: '__',\n    __n: '__n',\n    __l: '__l',\n    __h: '__h',\n    __mf: '__mf',\n    getLocale: 'getLocale',\n    setLocale: 'setLocale',\n    getCatalog: 'getCatalog',\n    getLocales: 'getLocales',\n    addLocale: 'addLocale',\n    removeLocale: 'removeLocale'\n  }\n  var mustacheConfig = {\n    tags: ['{{', '}}'],\n    disable: false\n  }\n  var mustacheRegex\n  var pathsep = path.sep // ---> means win support will be available in node 0.8.x and above\n  var autoReload\n  var cookiename\n  var languageHeaderName\n  var defaultLocale\n  var retryInDefaultLocale\n  var directory\n  var directoryPermissions\n  var extension\n  var fallbacks\n  var indent\n  var logDebugFn\n  var logErrorFn\n  var logWarnFn\n  var preserveLegacyCase\n  var objectNotation\n  var prefix\n  var queryParameter\n  var register\n  var updateFiles\n  var syncFiles\n  var missingKeyFn\n\n  // public exports\n  var i18n = {}\n\n  i18n.version = pkgVersion\n\n  i18n.configure = function i18nConfigure(opt) {\n    // reset locales\n    locales = {}\n\n    // Provide custom API method aliases if desired\n    // This needs to be processed before the first call to applyAPItoObject()\n    if (opt.api && typeof opt.api === 'object') {\n      for (var method in opt.api) {\n        if (Object.prototype.hasOwnProperty.call(opt.api, method)) {\n          var alias = opt.api[method]\n          if (typeof api[method] !== 'undefined') {\n            api[method] = alias\n          }\n        }\n      }\n    }\n\n    // you may register i18n in global scope, up to you\n    if (typeof opt.register === 'object') {\n      register = opt.register\n      // or give an array objects to register to\n      if (Array.isArray(opt.register)) {\n        register = opt.register\n        register.forEach(function (r) {\n          applyAPItoObject(r)\n        })\n      } else {\n        applyAPItoObject(opt.register)\n      }\n    }\n\n    // sets a custom cookie name to parse locale settings from\n    cookiename = typeof opt.cookie === 'string' ? opt.cookie : null\n\n    // set the custom header name to extract the language locale\n    languageHeaderName =\n      typeof opt.header === 'string' ? opt.header : 'accept-language'\n\n    // query-string parameter to be watched - @todo: add test & doc\n    queryParameter =\n      typeof opt.queryParameter === 'string' ? opt.queryParameter : null\n\n    // where to store json files\n    directory =\n      typeof opt.directory === 'string'\n        ? opt.directory\n        : path.join(__dirname, 'locales')\n\n    // permissions when creating new directories\n    directoryPermissions =\n      typeof opt.directoryPermissions === 'string'\n        ? parseInt(opt.directoryPermissions, 8)\n        : null\n\n    // write new locale information to disk\n    updateFiles = typeof opt.updateFiles === 'boolean' ? opt.updateFiles : true\n\n    // sync locale information accros all files\n    syncFiles = typeof opt.syncFiles === 'boolean' ? opt.syncFiles : false\n\n    // what to use as the indentation unit (ex: \"\\t\", \"  \")\n    indent = typeof opt.indent === 'string' ? opt.indent : '\\t'\n\n    // json files prefix\n    prefix = typeof opt.prefix === 'string' ? opt.prefix : ''\n\n    // where to store json files\n    extension = typeof opt.extension === 'string' ? opt.extension : '.json'\n\n    // setting defaultLocale\n    defaultLocale =\n      typeof opt.defaultLocale === 'string' ? opt.defaultLocale : 'en'\n\n    // allow to retry in default locale, useful for production\n    retryInDefaultLocale =\n      typeof opt.retryInDefaultLocale === 'boolean'\n        ? opt.retryInDefaultLocale\n        : false\n\n    // auto reload locale files when changed\n    autoReload = typeof opt.autoReload === 'boolean' ? opt.autoReload : false\n\n    // enable object notation?\n    objectNotation =\n      typeof opt.objectNotation !== 'undefined' ? opt.objectNotation : false\n    if (objectNotation === true) objectNotation = '.'\n\n    // read language fallback map\n    fallbacks = typeof opt.fallbacks === 'object' ? opt.fallbacks : {}\n\n    // setting custom logger functions\n    logDebugFn = typeof opt.logDebugFn === 'function' ? opt.logDebugFn : debug\n    logWarnFn = typeof opt.logWarnFn === 'function' ? opt.logWarnFn : warn\n    logErrorFn = typeof opt.logErrorFn === 'function' ? opt.logErrorFn : error\n\n    preserveLegacyCase =\n      typeof opt.preserveLegacyCase === 'boolean'\n        ? opt.preserveLegacyCase\n        : true\n\n    // setting custom missing key function\n    missingKeyFn =\n      typeof opt.missingKeyFn === 'function' ? opt.missingKeyFn : missingKey\n\n    // when missing locales we try to guess that from directory\n    opt.locales = opt.staticCatalog\n      ? Object.keys(opt.staticCatalog)\n      : opt.locales || guessLocales(directory)\n\n    // some options should be disabled when using staticCatalog\n    if (opt.staticCatalog) {\n      updateFiles = false\n      autoReload = false\n      syncFiles = false\n    }\n\n    // customize mustache parsing\n    if (opt.mustacheConfig) {\n      if (Array.isArray(opt.mustacheConfig.tags)) {\n        mustacheConfig.tags = opt.mustacheConfig.tags\n      }\n      if (opt.mustacheConfig.disable === true) {\n        mustacheConfig.disable = true\n      }\n    }\n\n    const [start, end] = mustacheConfig.tags\n    mustacheRegex = new RegExp(escapeRegExp(start) + '.*' + escapeRegExp(end))\n\n    // implicitly read all locales\n    if (Array.isArray(opt.locales)) {\n      if (opt.staticCatalog) {\n        locales = opt.staticCatalog\n      } else {\n        opt.locales.forEach(function (l) {\n          read(l)\n        })\n      }\n\n      // auto reload locale files when changed\n      if (autoReload) {\n        // watch changes of locale files (it's called twice because fs.watch is still unstable)\n        fs.watch(directory, function (event, filename) {\n          var localeFromFile = guessLocaleFromFile(filename)\n\n          if (localeFromFile && opt.locales.indexOf(localeFromFile) > -1) {\n            logDebug('Auto reloading locale file \"' + filename + '\".')\n            read(localeFromFile)\n          }\n        })\n      }\n    }\n  }\n\n  i18n.init = function i18nInit(request, response, next) {\n    if (typeof request === 'object') {\n      // guess requested language/locale\n      guessLanguage(request)\n\n      // bind api to req\n      applyAPItoObject(request)\n\n      // looks double but will ensure schema on api refactor\n      i18n.setLocale(request, request.locale)\n    } else {\n      return logError(\n        'i18n.init must be called with one parameter minimum, ie. i18n.init(req)'\n      )\n    }\n\n    if (typeof response === 'object') {\n      applyAPItoObject(response)\n\n      // and set that locale to response too\n      i18n.setLocale(response, request.locale)\n    }\n\n    // head over to next callback when bound as middleware\n    if (typeof next === 'function') {\n      return next()\n    }\n  }\n\n  i18n.__ = function i18nTranslate(phrase) {\n    var msg\n    var argv = parseArgv(arguments)\n    var namedValues = argv[0]\n    var args = argv[1]\n\n    // called like __({phrase: \"Hello\", locale: \"en\"})\n    if (typeof phrase === 'object') {\n      if (\n        typeof phrase.locale === 'string' &&\n        typeof phrase.phrase === 'string'\n      ) {\n        msg = translate(phrase.locale, phrase.phrase)\n      }\n    }\n    // called like __(\"Hello\")\n    else {\n      // get translated message with locale from scope (deprecated) or object\n      msg = translate(getLocaleFromObject(this), phrase)\n    }\n\n    // postprocess to get compatible to plurals\n    if (typeof msg === 'object' && msg.one) {\n      msg = msg.one\n    }\n\n    // in case there is no 'one' but an 'other' rule\n    if (typeof msg === 'object' && msg.other) {\n      msg = msg.other\n    }\n\n    // head over to postProcessing\n    return postProcess(msg, namedValues, args)\n  }\n\n  i18n.__mf = function i18nMessageformat(phrase) {\n    var msg, mf, f\n    var targetLocale = defaultLocale\n    var argv = parseArgv(arguments)\n    var namedValues = argv[0]\n    var args = argv[1]\n\n    // called like __({phrase: \"Hello\", locale: \"en\"})\n    if (typeof phrase === 'object') {\n      if (\n        typeof phrase.locale === 'string' &&\n        typeof phrase.phrase === 'string'\n      ) {\n        msg = phrase.phrase\n        targetLocale = phrase.locale\n      }\n    }\n    // called like __(\"Hello\")\n    else {\n      // get translated message with locale from scope (deprecated) or object\n      msg = phrase\n      targetLocale = getLocaleFromObject(this)\n    }\n\n    msg = translate(targetLocale, msg)\n    // --- end get msg\n\n    // now head over to Messageformat\n    // and try to cache instance\n    if (MessageformatInstanceForLocale[targetLocale]) {\n      mf = MessageformatInstanceForLocale[targetLocale]\n    } else {\n      mf = new Messageformat(targetLocale)\n\n      // @see https://messageformat.github.io/messageformat/MessageFormat#disablePluralKeyChecks__anchor\n      mf.disablePluralKeyChecks()\n      mf.compiledFunctions = {}\n      MessageformatInstanceForLocale[targetLocale] = mf\n    }\n\n    // let's try to cache that function\n    if (mf.compiledFunctions[msg]) {\n      f = mf.compiledFunctions[msg]\n    } else {\n      f = mf.compile(msg)\n      mf.compiledFunctions[msg] = f\n    }\n\n    return postProcess(f(namedValues), namedValues, args)\n  }\n\n  i18n.__l = function i18nTranslationList(phrase) {\n    var translations = []\n    Object.keys(locales)\n      .sort()\n      .forEach(function (l) {\n        translations.push(i18n.__({ phrase: phrase, locale: l }))\n      })\n    return translations\n  }\n\n  i18n.__h = function i18nTranslationHash(phrase) {\n    var translations = []\n    Object.keys(locales)\n      .sort()\n      .forEach(function (l) {\n        var hash = {}\n        hash[l] = i18n.__({ phrase: phrase, locale: l })\n        translations.push(hash)\n      })\n    return translations\n  }\n\n  i18n.__n = function i18nTranslatePlural(singular, plural, count) {\n    var msg\n    var namedValues\n    var targetLocale\n    var args = []\n\n    // Accept an object with named values as the last parameter\n    if (argsEndWithNamedObject(arguments)) {\n      namedValues = arguments[arguments.length - 1]\n      args =\n        arguments.length >= 5\n          ? Array.prototype.slice.call(arguments, 3, -1)\n          : []\n    } else {\n      namedValues = {}\n      args =\n        arguments.length >= 4 ? Array.prototype.slice.call(arguments, 3) : []\n    }\n\n    // called like __n({singular: \"%s cat\", plural: \"%s cats\", locale: \"en\"}, 3)\n    if (typeof singular === 'object') {\n      if (\n        typeof singular.locale === 'string' &&\n        typeof singular.singular === 'string' &&\n        typeof singular.plural === 'string'\n      ) {\n        targetLocale = singular.locale\n        msg = translate(singular.locale, singular.singular, singular.plural)\n      }\n      args.unshift(count)\n\n      // some template engines pass all values as strings -> so we try to convert them to numbers\n      if (typeof plural === 'number' || Number(plural) + '' === plural) {\n        count = plural\n      }\n\n      // called like __n({singular: \"%s cat\", plural: \"%s cats\", locale: \"en\", count: 3})\n      if (\n        typeof singular.count === 'number' ||\n        typeof singular.count === 'string'\n      ) {\n        count = singular.count\n        args.unshift(plural)\n      }\n    } else {\n      // called like  __n('cat', 3)\n      if (typeof plural === 'number' || Number(plural) + '' === plural) {\n        count = plural\n\n        // we add same string as default\n        // which efectivly copies the key to the plural.value\n        // this is for initialization of new empty translations\n        plural = singular\n\n        args.unshift(count)\n        args.unshift(plural)\n      }\n      // called like __n('%s cat', '%s cats', 3)\n      // get translated message with locale from scope (deprecated) or object\n      msg = translate(getLocaleFromObject(this), singular, plural)\n      targetLocale = getLocaleFromObject(this)\n    }\n\n    if (count === null) count = namedValues.count\n\n    // enforce number\n    count = Number(count)\n\n    // find the correct plural rule for given locale\n    if (typeof msg === 'object') {\n      var p\n      // create a new Plural for locale\n      // and try to cache instance\n      if (PluralsForLocale[targetLocale]) {\n        p = PluralsForLocale[targetLocale]\n      } else {\n        // split locales with a region code\n        var lc = targetLocale\n          .toLowerCase()\n          .split(/[_-\\s]+/)\n          .filter(function (el) {\n            return true && el\n          })\n        // take the first part of locale, fallback to full locale\n        p = MakePlural[lc[0] || targetLocale]\n        PluralsForLocale[targetLocale] = p\n      }\n\n      // fallback to 'other' on case of missing translations\n      msg = msg[p(count)] || msg.other\n    }\n\n    // head over to postProcessing\n    return postProcess(msg, namedValues, args, count)\n  }\n\n  i18n.setLocale = function i18nSetLocale(object, locale, skipImplicitObjects) {\n    // when given an array of objects => setLocale on each\n    if (Array.isArray(object) && typeof locale === 'string') {\n      for (var i = object.length - 1; i >= 0; i--) {\n        i18n.setLocale(object[i], locale, true)\n      }\n      return i18n.getLocale(object[0])\n    }\n\n    // defaults to called like i18n.setLocale(req, 'en')\n    var targetObject = object\n    var targetLocale = locale\n\n    // called like req.setLocale('en') or i18n.setLocale('en')\n    if (locale === undefined && typeof object === 'string') {\n      targetObject = this\n      targetLocale = object\n    }\n\n    // consider a fallback\n    if (!locales[targetLocale]) {\n      targetLocale = getFallback(targetLocale, fallbacks) || targetLocale\n    }\n\n    // now set locale on object\n    targetObject.locale = locales[targetLocale] ? targetLocale : defaultLocale\n\n    // consider any extra registered objects\n    if (typeof register === 'object') {\n      if (Array.isArray(register) && !skipImplicitObjects) {\n        register.forEach(function (r) {\n          r.locale = targetObject.locale\n        })\n      } else {\n        register.locale = targetObject.locale\n      }\n    }\n\n    // consider res\n    if (targetObject.res && !skipImplicitObjects) {\n      // escape recursion\n      // @see  - https://github.com/balderdashy/sails/pull/3631\n      //       - https://github.com/mashpie/i18n-node/pull/218\n      if (targetObject.res.locals) {\n        i18n.setLocale(targetObject.res, targetObject.locale, true)\n        i18n.setLocale(targetObject.res.locals, targetObject.locale, true)\n      } else {\n        i18n.setLocale(targetObject.res, targetObject.locale)\n      }\n    }\n\n    // consider locals\n    if (targetObject.locals && !skipImplicitObjects) {\n      // escape recursion\n      // @see  - https://github.com/balderdashy/sails/pull/3631\n      //       - https://github.com/mashpie/i18n-node/pull/218\n      if (targetObject.locals.res) {\n        i18n.setLocale(targetObject.locals, targetObject.locale, true)\n        i18n.setLocale(targetObject.locals.res, targetObject.locale, true)\n      } else {\n        i18n.setLocale(targetObject.locals, targetObject.locale)\n      }\n    }\n\n    return i18n.getLocale(targetObject)\n  }\n\n  i18n.getLocale = function i18nGetLocale(request) {\n    // called like i18n.getLocale(req)\n    if (request && request.locale) {\n      return request.locale\n    }\n\n    // called like req.getLocale()\n    return this.locale || defaultLocale\n  }\n\n  i18n.getCatalog = function i18nGetCatalog(object, locale) {\n    var targetLocale\n\n    // called like i18n.getCatalog(req)\n    if (\n      typeof object === 'object' &&\n      typeof object.locale === 'string' &&\n      locale === undefined\n    ) {\n      targetLocale = object.locale\n    }\n\n    // called like i18n.getCatalog(req, 'en')\n    if (\n      !targetLocale &&\n      typeof object === 'object' &&\n      typeof locale === 'string'\n    ) {\n      targetLocale = locale\n    }\n\n    // called like req.getCatalog('en')\n    if (!targetLocale && locale === undefined && typeof object === 'string') {\n      targetLocale = object\n    }\n\n    // called like req.getCatalog()\n    if (\n      !targetLocale &&\n      object === undefined &&\n      locale === undefined &&\n      typeof this.locale === 'string'\n    ) {\n      if (register && register.global) {\n        targetLocale = ''\n      } else {\n        targetLocale = this.locale\n      }\n    }\n\n    // called like i18n.getCatalog()\n    if (targetLocale === undefined || targetLocale === '') {\n      return locales\n    }\n\n    if (!locales[targetLocale]) {\n      targetLocale = getFallback(targetLocale, fallbacks) || targetLocale\n    }\n\n    if (locales[targetLocale]) {\n      return locales[targetLocale]\n    } else {\n      logWarn('No catalog found for \"' + targetLocale + '\"')\n      return false\n    }\n  }\n\n  i18n.getLocales = function i18nGetLocales() {\n    return Object.keys(locales)\n  }\n\n  i18n.addLocale = function i18nAddLocale(locale) {\n    read(locale)\n  }\n\n  i18n.removeLocale = function i18nRemoveLocale(locale) {\n    delete locales[locale]\n  }\n\n  // ===================\n  // = private methods =\n  // ===================\n\n  var postProcess = function (msg, namedValues, args, count) {\n    // test for parsable interval string\n    if (/\\|/.test(msg)) {\n      msg = parsePluralInterval(msg, count)\n    }\n\n    // replace the counter\n    if (typeof count === 'number') {\n      msg = vsprintf(msg, [Number(count)])\n    }\n\n    // if the msg string contains {{Mustache}} patterns we render it as a mini tempalate\n    if (!mustacheConfig.disable && mustacheRegex.test(msg)) {\n      msg = Mustache.render(msg, namedValues, {}, mustacheConfig.tags)\n    }\n\n    // if we have extra arguments with values to get replaced,\n    // an additional substition injects those strings afterwards\n    if (/%/.test(msg) && args && args.length > 0) {\n      msg = vsprintf(msg, args)\n    }\n\n    return msg\n  }\n\n  var argsEndWithNamedObject = function (args) {\n    return (\n      args.length > 1 &&\n      args[args.length - 1] !== null &&\n      typeof args[args.length - 1] === 'object'\n    )\n  }\n\n  var parseArgv = function (args) {\n    var namedValues, returnArgs\n\n    if (argsEndWithNamedObject(args)) {\n      namedValues = args[args.length - 1]\n      returnArgs = Array.prototype.slice.call(args, 1, -1)\n    } else {\n      namedValues = {}\n      returnArgs = args.length >= 2 ? Array.prototype.slice.call(args, 1) : []\n    }\n\n    return [namedValues, returnArgs]\n  }\n\n  /**\n   * registers all public API methods to a given response object when not already declared\n   */\n  var applyAPItoObject = function (object) {\n    var alreadySetted = true\n\n    // attach to itself if not provided\n    for (var method in api) {\n      if (Object.prototype.hasOwnProperty.call(api, method)) {\n        var alias = api[method]\n\n        // be kind rewind, or better not touch anything already existing\n        if (!object[alias]) {\n          alreadySetted = false\n          object[alias] = i18n[method].bind(object)\n        }\n      }\n    }\n\n    // set initial locale if not set\n    if (!object.locale) {\n      object.locale = defaultLocale\n    }\n\n    // escape recursion\n    if (alreadySetted) {\n      return\n    }\n\n    // attach to response if present (ie. in express)\n    if (object.res) {\n      applyAPItoObject(object.res)\n    }\n\n    // attach to locals if present (ie. in express)\n    if (object.locals) {\n      applyAPItoObject(object.locals)\n    }\n  }\n\n  /**\n   * tries to guess locales by scanning the given directory\n   */\n  var guessLocales = function (directory) {\n    var entries = fs.readdirSync(directory)\n    var localesFound = []\n\n    for (var i = entries.length - 1; i >= 0; i--) {\n      if (entries[i].match(/^\\./)) continue\n      var localeFromFile = guessLocaleFromFile(entries[i])\n      if (localeFromFile) localesFound.push(localeFromFile)\n    }\n\n    return localesFound.sort()\n  }\n\n  /**\n   * tries to guess locales from a given filename\n   */\n  var guessLocaleFromFile = function (filename) {\n    var extensionRegex = new RegExp(extension + '$', 'g')\n    var prefixRegex = new RegExp('^' + prefix, 'g')\n\n    if (!filename) return false\n    if (prefix && !filename.match(prefixRegex)) return false\n    if (extension && !filename.match(extensionRegex)) return false\n    return filename.replace(prefix, '').replace(extensionRegex, '')\n  }\n\n  /**\n   * @param queryLanguage - language query parameter, either an array or a string.\n   * @return the first non-empty language query parameter found, null otherwise.\n   */\n  var extractQueryLanguage = function (queryLanguage) {\n    if (Array.isArray(queryLanguage)) {\n      return queryLanguage.find((lang) => lang !== '' && lang)\n    }\n    return typeof queryLanguage === 'string' && queryLanguage\n  }\n\n  /**\n   * guess language setting based on http headers\n   */\n\n  var guessLanguage = function (request) {\n    if (typeof request === 'object') {\n      var languageHeader = request.headers\n        ? request.headers[languageHeaderName]\n        : undefined\n      var languages = []\n      var regions = []\n\n      request.languages = [defaultLocale]\n      request.regions = [defaultLocale]\n      request.language = defaultLocale\n      request.region = defaultLocale\n\n      // a query parameter overwrites all\n      if (queryParameter && request.url) {\n        var urlAsString =\n          typeof request.url === 'string' ? request.url : request.url.toString()\n\n        /**\n         * @todo WHATWG new URL() requires full URL including hostname - that might change\n         * @see https://github.com/nodejs/node/issues/12682\n         */\n        // eslint-disable-next-line node/no-deprecated-api\n        var urlObj = url.parse(urlAsString, true)\n        var languageQueryParameter = urlObj.query[queryParameter]\n        if (languageQueryParameter) {\n          let queryLanguage = extractQueryLanguage(languageQueryParameter)\n          if (queryLanguage) {\n            logDebug('Overriding locale from query: ' + queryLanguage)\n            if (preserveLegacyCase) {\n              queryLanguage = queryLanguage.toLowerCase()\n            }\n            return i18n.setLocale(request, queryLanguage)\n          }\n        }\n      }\n\n      // a cookie overwrites headers\n      if (cookiename && request.cookies && request.cookies[cookiename]) {\n        request.language = request.cookies[cookiename]\n        return i18n.setLocale(request, request.language)\n      }\n\n      // 'accept-language' is the most common source\n      if (languageHeader) {\n        var acceptedLanguages = getAcceptedLanguagesFromHeader(languageHeader)\n        var match\n        var fallbackMatch\n        var fallback\n        for (var i = 0; i < acceptedLanguages.length; i++) {\n          var lang = acceptedLanguages[i]\n          var lr = lang.split('-', 2)\n          var parentLang = lr[0]\n          var region = lr[1]\n\n          // Check if we have a configured fallback set for this language.\n          var fallbackLang = getFallback(lang, fallbacks)\n          if (fallbackLang) {\n            fallback = fallbackLang\n            // Fallbacks for languages should be inserted\n            // where the original, unsupported language existed.\n            var acceptedLanguageIndex = acceptedLanguages.indexOf(lang)\n            var fallbackIndex = acceptedLanguages.indexOf(fallback)\n            if (fallbackIndex > -1) {\n              acceptedLanguages.splice(fallbackIndex, 1)\n            }\n            acceptedLanguages.splice(acceptedLanguageIndex + 1, 0, fallback)\n          }\n\n          // Check if we have a configured fallback set for the parent language of the locale.\n          var fallbackParentLang = getFallback(parentLang, fallbacks)\n          if (fallbackParentLang) {\n            fallback = fallbackParentLang\n            // Fallbacks for a parent language should be inserted\n            // to the end of the list, so they're only picked\n            // if there is no better match.\n            if (acceptedLanguages.indexOf(fallback) < 0) {\n              acceptedLanguages.push(fallback)\n            }\n          }\n\n          if (languages.indexOf(parentLang) < 0) {\n            languages.push(parentLang.toLowerCase())\n          }\n          if (region) {\n            regions.push(region.toLowerCase())\n          }\n\n          if (!match && locales[lang]) {\n            match = lang\n            break\n          }\n\n          if (!fallbackMatch && locales[parentLang]) {\n            fallbackMatch = parentLang\n          }\n        }\n\n        request.language = match || fallbackMatch || request.language\n        request.region = regions[0] || request.region\n        return i18n.setLocale(request, request.language)\n      }\n    }\n\n    // last resort: defaultLocale\n    return i18n.setLocale(request, defaultLocale)\n  }\n\n  /**\n   * Get a sorted list of accepted languages from the HTTP Accept-Language header\n   */\n  var getAcceptedLanguagesFromHeader = function (header) {\n    var languages = header.split(',')\n    var preferences = {}\n    return languages\n      .map(function parseLanguagePreference(item) {\n        var preferenceParts = item.trim().split(';q=')\n        if (preferenceParts.length < 2) {\n          preferenceParts[1] = 1.0\n        } else {\n          var quality = parseFloat(preferenceParts[1])\n          preferenceParts[1] = quality || 0.0\n        }\n        preferences[preferenceParts[0]] = preferenceParts[1]\n\n        return preferenceParts[0]\n      })\n      .filter(function (lang) {\n        return preferences[lang] > 0\n      })\n      .sort(function sortLanguages(a, b) {\n        return preferences[b] - preferences[a]\n      })\n  }\n\n  /**\n   * searches for locale in given object\n   */\n\n  var getLocaleFromObject = function (obj) {\n    var locale\n    if (obj && obj.scope) {\n      locale = obj.scope.locale\n    }\n    if (obj && obj.locale) {\n      locale = obj.locale\n    }\n    return locale\n  }\n\n  /**\n   * splits and parses a phrase for mathematical interval expressions\n   */\n  var parsePluralInterval = function (phrase, count) {\n    var returnPhrase = phrase\n    var phrases = phrase.split(/\\|/)\n    var intervalRuleExists = false\n\n    // some() breaks on 1st true\n    phrases.some(function (p) {\n      var matches = p.match(/^\\s*([()[\\]]+[\\d,]+[()[\\]]+)?\\s*(.*)$/)\n\n      // not the same as in combined condition\n      if (matches != null && matches[1]) {\n        intervalRuleExists = true\n        if (matchInterval(count, matches[1]) === true) {\n          returnPhrase = matches[2]\n          return true\n        }\n      } else {\n        // this is a other or catch all case, this only is taken into account if there is actually another rule\n        if (intervalRuleExists) {\n          returnPhrase = p\n        }\n      }\n    })\n    return returnPhrase\n  }\n\n  /**\n   * test a number to match mathematical interval expressions\n   * [0,2] - 0 to 2 (including, matches: 0, 1, 2)\n   * ]0,3[ - 0 to 3 (excluding, matches: 1, 2)\n   * [1]   - 1 (matches: 1)\n   * [20,] - all numbers ≥20 (matches: 20, 21, 22, ...)\n   * [,20] - all numbers ≤20 (matches: 20, 21, 22, ...)\n   */\n  var matchInterval = function (number, interval) {\n    interval = parseInterval(interval)\n    if (interval && typeof number === 'number') {\n      if (interval.from.value === number) {\n        return interval.from.included\n      }\n      if (interval.to.value === number) {\n        return interval.to.included\n      }\n\n      return (\n        Math.min(interval.from.value, number) === interval.from.value &&\n        Math.max(interval.to.value, number) === interval.to.value\n      )\n    }\n    return false\n  }\n\n  /**\n   * read locale file, translate a msg and write to fs if new\n   */\n  var translate = function (locale, singular, plural, skipSyncToAllFiles) {\n    // add same key to all translations\n    if (!skipSyncToAllFiles && syncFiles) {\n      syncToAllFiles(singular, plural)\n    }\n\n    if (locale === undefined) {\n      logWarn(\n        'WARN: No locale found - check the context of the call to __(). Using ' +\n          defaultLocale +\n          ' as current locale'\n      )\n      locale = defaultLocale\n    }\n\n    // try to get a fallback\n    if (!locales[locale]) {\n      locale = getFallback(locale, fallbacks) || locale\n    }\n\n    // attempt to read when defined as valid locale\n    if (!locales[locale]) {\n      read(locale)\n    }\n\n    // fallback to default when missed\n    if (!locales[locale]) {\n      logWarn(\n        'WARN: Locale ' +\n          locale +\n          \" couldn't be read - check the context of the call to $__. Using \" +\n          defaultLocale +\n          ' (default) as current locale'\n      )\n\n      locale = defaultLocale\n      read(locale)\n    }\n\n    // dotnotaction add on, @todo: factor out\n    var defaultSingular = singular\n    var defaultPlural = plural\n    if (objectNotation) {\n      var indexOfColon = singular.indexOf(':')\n      // We compare against 0 instead of -1 because\n      // we don't really expect the string to start with ':'.\n      if (indexOfColon > 0) {\n        defaultSingular = singular.substring(indexOfColon + 1)\n        singular = singular.substring(0, indexOfColon)\n      }\n      if (plural && typeof plural !== 'number') {\n        indexOfColon = plural.indexOf(':')\n        if (indexOfColon > 0) {\n          defaultPlural = plural.substring(indexOfColon + 1)\n          plural = plural.substring(0, indexOfColon)\n        }\n      }\n    }\n\n    var accessor = localeAccessor(locale, singular)\n    var mutator = localeMutator(locale, singular)\n\n    // if (plural) {\n    //   if (accessor() == null) {\n    //     mutator({\n    //       'one': defaultSingular || singular,\n    //       'other': defaultPlural || plural\n    //     });\n    //     write(locale);\n    //   }\n    // }\n\n    // if (accessor() == null) {\n    //   mutator(defaultSingular || singular);\n    //   write(locale);\n    // }\n\n    if (plural) {\n      if (accessor() == null) {\n        // when retryInDefaultLocale is true - try to set default value from defaultLocale\n        if (retryInDefaultLocale && locale !== defaultLocale) {\n          logDebug(\n            'Missing ' +\n              singular +\n              ' in ' +\n              locale +\n              ' retrying in ' +\n              defaultLocale\n          )\n          mutator(translate(defaultLocale, singular, plural))\n        } else {\n          mutator({\n            one: defaultSingular || singular,\n            other: defaultPlural || plural\n          })\n        }\n        write(locale)\n      }\n    }\n\n    if (accessor() == null) {\n      // when retryInDefaultLocale is true - try to set default value from defaultLocale\n      if (retryInDefaultLocale && locale !== defaultLocale) {\n        logDebug(\n          'Missing ' +\n            singular +\n            ' in ' +\n            locale +\n            ' retrying in ' +\n            defaultLocale\n        )\n        mutator(translate(defaultLocale, singular, plural))\n      } else {\n        mutator(defaultSingular || singular)\n      }\n      write(locale)\n    }\n\n    return accessor()\n  }\n\n  /**\n   * initialize the same key in all locales\n   * when not already existing, checked via translate\n   */\n  var syncToAllFiles = function (singular, plural) {\n    // iterate over locales and translate again\n    // this will implicitly write/sync missing keys\n    // to the rest of locales\n    for (var l in locales) {\n      translate(l, singular, plural, true)\n    }\n  }\n\n  /**\n   * Allows delayed access to translations nested inside objects.\n   * @param {String} locale The locale to use.\n   * @param {String} singular The singular term to look up.\n   * @param {Boolean} [allowDelayedTraversal=true] Is delayed traversal of the tree allowed?\n   * This parameter is used internally. It allows to signal the accessor that\n   * a translation was not found in the initial lookup and that an invocation\n   * of the accessor may trigger another traversal of the tree.\n   * @returns {Function} A function that, when invoked, returns the current value stored\n   * in the object at the requested location.\n   */\n  var localeAccessor = function (locale, singular, allowDelayedTraversal) {\n    // Bail out on non-existent locales to defend against internal errors.\n    if (!locales[locale]) return Function.prototype\n\n    // Handle object lookup notation\n    var indexOfDot = objectNotation && singular.lastIndexOf(objectNotation)\n    if (objectNotation && indexOfDot > 0 && indexOfDot < singular.length - 1) {\n      // If delayed traversal wasn't specifically forbidden, it is allowed.\n      if (typeof allowDelayedTraversal === 'undefined')\n        allowDelayedTraversal = true\n      // The accessor we're trying to find and which we want to return.\n      var accessor = null\n      // An accessor that returns null.\n      var nullAccessor = function () {\n        return null\n      }\n      // Do we need to re-traverse the tree upon invocation of the accessor?\n      var reTraverse = false\n      // Split the provided term and run the callback for each subterm.\n      singular.split(objectNotation).reduce(function (object, index) {\n        // Make the accessor return null.\n        accessor = nullAccessor\n        // If our current target object (in the locale tree) doesn't exist or\n        // it doesn't have the next subterm as a member...\n        if (\n          object === null ||\n          !Object.prototype.hasOwnProperty.call(object, index)\n        ) {\n          // ...remember that we need retraversal (because we didn't find our target).\n          reTraverse = allowDelayedTraversal\n          // Return null to avoid deeper iterations.\n          return null\n        }\n        // We can traverse deeper, so we generate an accessor for this current level.\n        accessor = function () {\n          return object[index]\n        }\n        // Return a reference to the next deeper level in the locale tree.\n        return object[index]\n      }, locales[locale])\n      // Return the requested accessor.\n      return function () {\n        // If we need to re-traverse (because we didn't find our target term)\n        // traverse again and return the new result (but don't allow further iterations)\n        // or return the previously found accessor if it was already valid.\n        return reTraverse\n          ? localeAccessor(locale, singular, false)()\n          : accessor()\n      }\n    } else {\n      // No object notation, just return an accessor that performs array lookup.\n      return function () {\n        return locales[locale][singular]\n      }\n    }\n  }\n\n  /**\n   * Allows delayed mutation of a translation nested inside objects.\n   * @description Construction of the mutator will attempt to locate the requested term\n   * inside the object, but if part of the branch does not exist yet, it will not be\n   * created until the mutator is actually invoked. At that point, re-traversal of the\n   * tree is performed and missing parts along the branch will be created.\n   * @param {String} locale The locale to use.\n   * @param {String} singular The singular term to look up.\n   * @param [Boolean} [allowBranching=false] Is the mutator allowed to create previously\n   * non-existent branches along the requested locale path?\n   * @returns {Function} A function that takes one argument. When the function is\n   * invoked, the targeted translation term will be set to the given value inside the locale table.\n   */\n  var localeMutator = function (locale, singular, allowBranching) {\n    // Bail out on non-existent locales to defend against internal errors.\n    if (!locales[locale]) return Function.prototype\n\n    // Handle object lookup notation\n    var indexOfDot = objectNotation && singular.lastIndexOf(objectNotation)\n    if (objectNotation && indexOfDot > 0 && indexOfDot < singular.length - 1) {\n      // If branching wasn't specifically allowed, disable it.\n      if (typeof allowBranching === 'undefined') allowBranching = false\n      // This will become the function we want to return.\n      var accessor = null\n      // An accessor that takes one argument and returns null.\n      var nullAccessor = function () {\n        return null\n      }\n      // Fix object path.\n      var fixObject = function () {\n        return {}\n      }\n      // Are we going to need to re-traverse the tree when the mutator is invoked?\n      var reTraverse = false\n      // Split the provided term and run the callback for each subterm.\n      singular.split(objectNotation).reduce(function (object, index) {\n        // Make the mutator do nothing.\n        accessor = nullAccessor\n        // If our current target object (in the locale tree) doesn't exist or\n        // it doesn't have the next subterm as a member...\n        if (\n          object === null ||\n          !Object.prototype.hasOwnProperty.call(object, index)\n        ) {\n          // ...check if we're allowed to create new branches.\n          if (allowBranching) {\n            // Fix `object` if `object` is not Object.\n            if (object === null || typeof object !== 'object') {\n              object = fixObject()\n            }\n            // If we are allowed to, create a new object along the path.\n            object[index] = {}\n          } else {\n            // If we aren't allowed, remember that we need to re-traverse later on and...\n            reTraverse = true\n            // ...return null to make the next iteration bail our early on.\n            return null\n          }\n        }\n        // Generate a mutator for the current level.\n        accessor = function (value) {\n          object[index] = value\n          return value\n        }\n        // Generate a fixer for the current level.\n        fixObject = function () {\n          object[index] = {}\n          return object[index]\n        }\n\n        // Return a reference to the next deeper level in the locale tree.\n        return object[index]\n      }, locales[locale])\n\n      // Return the final mutator.\n      return function (value) {\n        // If we need to re-traverse the tree\n        // invoke the search again, but allow branching\n        // this time (because here the mutator is being invoked)\n        // otherwise, just change the value directly.\n        value = missingKeyFn(locale, value)\n        return reTraverse\n          ? localeMutator(locale, singular, true)(value)\n          : accessor(value)\n      }\n    } else {\n      // No object notation, just return a mutator that performs array lookup and changes the value.\n      return function (value) {\n        value = missingKeyFn(locale, value)\n        locales[locale][singular] = value\n        return value\n      }\n    }\n  }\n\n  /**\n   * try reading a file\n   */\n  var read = function (locale) {\n    var localeFile = {}\n    var file = getStorageFilePath(locale)\n    try {\n      logDebug('read ' + file + ' for locale: ' + locale)\n      localeFile = fs.readFileSync(file)\n      try {\n        // parsing filecontents to locales[locale]\n        locales[locale] = JSON.parse(localeFile)\n      } catch (parseError) {\n        logError(\n          'unable to parse locales from file (maybe ' +\n            file +\n            ' is empty or invalid json?): ',\n          parseError\n        )\n      }\n    } catch (readError) {\n      // unable to read, so intialize that file\n      // locales[locale] are already set in memory, so no extra read required\n      // or locales[locale] are empty, which initializes an empty locale.json file\n\n      // since the current invalid locale could exist, we should back it up\n      if (fs.existsSync(file)) {\n        logDebug(\n          'backing up invalid locale ' + locale + ' to ' + file + '.invalid'\n        )\n        fs.renameSync(file, file + '.invalid')\n      }\n\n      logDebug('initializing ' + file)\n      write(locale)\n    }\n  }\n\n  /**\n   * try writing a file in a created directory\n   */\n  var write = function (locale) {\n    var stats, target, tmp\n\n    // don't write new locale information to disk if updateFiles isn't true\n    if (!updateFiles) {\n      return\n    }\n\n    // creating directory if necessary\n    try {\n      stats = fs.lstatSync(directory)\n    } catch (e) {\n      logDebug('creating locales dir in: ' + directory)\n      try {\n        fs.mkdirSync(directory, directoryPermissions)\n      } catch (e) {\n        // in case of parallel tasks utilizing in same dir\n        if (e.code !== 'EEXIST') throw e\n      }\n    }\n\n    // first time init has an empty file\n    if (!locales[locale]) {\n      locales[locale] = {}\n    }\n\n    // writing to tmp and rename on success\n    try {\n      target = getStorageFilePath(locale)\n      tmp = target + '.tmp'\n      fs.writeFileSync(\n        tmp,\n        JSON.stringify(locales[locale], null, indent),\n        'utf8'\n      )\n      stats = fs.statSync(tmp)\n      if (stats.isFile()) {\n        fs.renameSync(tmp, target)\n      } else {\n        logError(\n          'unable to write locales to file (either ' +\n            tmp +\n            ' or ' +\n            target +\n            ' are not writeable?): '\n        )\n      }\n    } catch (e) {\n      logError(\n        'unexpected error writing files (either ' +\n          tmp +\n          ' or ' +\n          target +\n          ' are not writeable?): ',\n        e\n      )\n    }\n  }\n\n  /**\n   * basic normalization of filepath\n   */\n  var getStorageFilePath = function (locale) {\n    // changed API to use .json as default, #16\n    var ext = extension || '.json'\n    var filepath = path.normalize(directory + pathsep + prefix + locale + ext)\n    var filepathJS = path.normalize(\n      directory + pathsep + prefix + locale + '.js'\n    )\n    // use .js as fallback if already existing\n    try {\n      if (fs.statSync(filepathJS)) {\n        logDebug('using existing file ' + filepathJS)\n        extension = '.js'\n        return filepathJS\n      }\n    } catch (e) {\n      logDebug('will use ' + filepath)\n    }\n    return filepath\n  }\n\n  /**\n   * Get locales with wildcard support\n   */\n  var getFallback = function (targetLocale, fallbacks) {\n    fallbacks = fallbacks || {}\n    if (fallbacks[targetLocale]) return fallbacks[targetLocale]\n    var fallBackLocale = null\n    for (var key in fallbacks) {\n      if (targetLocale.match(new RegExp('^' + key.replace('*', '.*') + '$'))) {\n        fallBackLocale = fallbacks[key]\n        break\n      }\n    }\n    return fallBackLocale\n  }\n\n  /**\n   * Logging proxies\n   */\n  function logDebug(msg) {\n    logDebugFn(msg)\n  }\n\n  function logWarn(msg) {\n    logWarnFn(msg)\n  }\n\n  function logError(msg) {\n    logErrorFn(msg)\n  }\n\n  /**\n   * Missing key function\n   */\n  function missingKey(locale, value) {\n    return value\n  }\n\n  /**\n   * implicitly configure when created with given options\n   * @example\n   * const i18n = new I18n({\n   *   locales: ['en', 'fr']\n   * });\n   */\n  if (_OPTS) i18n.configure(_OPTS)\n\n  return i18n\n}\n\nmodule.exports = i18n\n"]},"metadata":{},"sourceType":"script"}