{"ast":null,"code":"import i18n from 'i18next';\nexport const getWeatherDescription = weather => {\n  var weatherItemReduce = (prevVal, currVal, idx) => {\n    // console.log(\"currVal.description: \" + currVal.description)\n    return idx === 0 ? i18n.t(`common.description.${currVal.description}`) : `${prevVal}` + \", \" + i18n.t(`common.description.${currVal.description}`);\n  };\n\n  return weather.weather.reduce(weatherItemReduce, '');\n};\nexport const displayDateTime = dateTime => {\n  return dateTime.toLocaleString(\"sk-SK\");\n};\nexport const convertTemperature = (convertTo, temp) => {\n  // console.log(convertTo)\n  if (convertTo === \"celsius\") return temp - 273.15;else if (convertTo === \"fahrenheit\") return (temp - 273.15) * 1.8 + 32;else return temp;\n};\nexport const keyExistsInArr = (arr, key) => {\n  let exists = false;\n\n  if (!Array.isArray(key)) {\n    arr === null || arr === void 0 ? void 0 : arr.some(item => {\n      if (item.hasOwnProperty([key])) {\n        exists = true;\n        return true;\n      } else return false;\n    });\n  } //since countries and descriptions is a multicheckbox, they are arrays and it has multiple keys and must check not with equals\n  else {\n      arr === null || arr === void 0 ? void 0 : arr.some(item => {\n        if (item.includes([key])) {\n          exists = true;\n          return true;\n        } else return false;\n      });\n    }\n\n  return exists;\n};\nexport const findIndexInFilters = (arr, key) => {\n  let indexOfKey = 0;\n  arr === null || arr === void 0 ? void 0 : arr.some((filterName, index, filters) => {\n    if (filterName.hasOwnProperty([key])) {\n      indexOfKey = index;\n      return indexOfKey;\n    } else return false;\n  });\n  return indexOfKey;\n};\nexport const changeFilters = (index, filterName, filterOperator, filters) => {\n  if (filters[index][filterName][filterOperator]) delete filters[index][filterName][filterOperator];\n  if (Object.keys(filters[index][filterName]).length === 0) filters.splice(index, 1);\n  return filters;\n};\nexport const addFilterOperatorToExistingFilterName = (event, filterName, filterOperator, filters) => {\n  filters.forEach((item, index, filters) => {\n    if (item.hasOwnProperty([filterName])) {\n      filters[index][filterName][filterOperator] = event;\n    }\n  });\n  return filters;\n};\nexport const isAdditionalFilterCheck = (event, index, filterName, filterOperator) => {\n  if (isNotAdditionalFilterWithContains(event) === false) return false;\n  if (isSameFilterChanged(event, index, filterName, filterOperator) === false) return false;\n  return true;\n}; //if there are multiple countries and descriptions, backend must make a new query\n//since no additional filter is added, only value. I am unable to send query request\n//with an array element\n\nexport const isNotAdditionalFilterWithContains = event => {\n  return event.includes(\",\") ? false : true;\n}; // this check is here for times when I change the same filter multiple\n// times in a row and the filter is same. If it is the same I cant filter\n// from memory because I could not load some weathers\n\nexport const isSameFilterChanged = (event, index, filterName, filterOperator) => {\n  return filterName === this.state.filters[index][filterName];\n};","map":{"version":3,"sources":["/home/prepelicamangalica/WorkspaceGit/SuperProjekt/src/main/ui/src/businessLogic/WeatherBusinessLogic.js"],"names":["i18n","getWeatherDescription","weather","weatherItemReduce","prevVal","currVal","idx","t","description","reduce","displayDateTime","dateTime","toLocaleString","convertTemperature","convertTo","temp","keyExistsInArr","arr","key","exists","Array","isArray","some","item","hasOwnProperty","includes","findIndexInFilters","indexOfKey","filterName","index","filters","changeFilters","filterOperator","Object","keys","length","splice","addFilterOperatorToExistingFilterName","event","forEach","isAdditionalFilterCheck","isNotAdditionalFilterWithContains","isSameFilterChanged","state"],"mappings":"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","sourcesContent":["import i18n from 'i18next'\nexport const getWeatherDescription = (weather) => {\n    var weatherItemReduce = (prevVal, currVal, idx) => {\n        // console.log(\"currVal.description: \" + currVal.description)\n        return idx === 0 ? i18n.t(`common.description.${currVal.description}`) : (`${prevVal}`) + \", \" + i18n.t(`common.description.${currVal.description}`);\n    }\n    return weather.weather.reduce(weatherItemReduce, '')\n}\n\nexport const displayDateTime = (dateTime) => {\n    return dateTime.toLocaleString(\"sk-SK\")\n}\n\nexport const convertTemperature = (convertTo, temp) => {\n    // console.log(convertTo)\n    if (convertTo === \"celsius\")\n        return temp - 273.15\n    else if (convertTo === \"fahrenheit\")\n        return (temp -273.15) * 1.8 + 32\n    else return temp\n}\n\n\nexport const keyExistsInArr = (arr, key) => {\n    let exists = false\n    if (!Array.isArray(key)){\n        arr?.some(item => {\n            if(item.hasOwnProperty([key])) {\n                exists = true;\n                return true\n            }\n            else return false\n        })\n    }\n    //since countries and descriptions is a multicheckbox, they are arrays and it has multiple keys and must check not with equals\n    else{\n        arr?.some(item => {\n            if(item.includes([key])) {\n                exists = true;\n                return true\n            }\n            else return false\n        })\n    }\n    return exists\n}\n\nexport const findIndexInFilters = (arr, key) => {\n    let indexOfKey = 0\n    arr?.some((filterName, index, filters) => {\n        if(filterName.hasOwnProperty([key])){ \n            indexOfKey = index\n            return indexOfKey\n        }\n        else return false\n    })\n    return indexOfKey\n}\n\nexport const changeFilters = (index, filterName, filterOperator, filters)  => {\n\n    if (filters[index][filterName][filterOperator])\n        delete filters[index][filterName][filterOperator]  \n    if (Object.keys(filters[index][filterName]).length === 0)\n        filters.splice(index, 1)\n    return filters\n}\n\nexport const addFilterOperatorToExistingFilterName = (event, filterName, filterOperator, filters) => {\n    filters.forEach((item, index, filters) => {\n        if (item.hasOwnProperty([filterName])){\n            filters[index][filterName][filterOperator] = event\n        }\n    })\n    return filters\n}\n\nexport const isAdditionalFilterCheck = (event, index, filterName, filterOperator) => {\n    if (isNotAdditionalFilterWithContains(event) === false)\n        return false\n    if (isSameFilterChanged(event, index, filterName, filterOperator) === false)\n        return false\n    return true\n            \n}   \n\n//if there are multiple countries and descriptions, backend must make a new query\n//since no additional filter is added, only value. I am unable to send query request\n//with an array element\nexport const isNotAdditionalFilterWithContains = (event) => {\n   return event.includes(\",\") ? false : true\n}\n\n// this check is here for times when I change the same filter multiple\n// times in a row and the filter is same. If it is the same I cant filter\n// from memory because I could not load some weathers\nexport const isSameFilterChanged = (event, index, filterName, filterOperator) => {\n   return filterName === this.state.filters[index][filterName]\n}"]},"metadata":{},"sourceType":"module"}